# JavaScript 중간점검 답안 및 해설

## 📋 채점 기준

- **객관식 문제**: 정답 선택 (각 7점)
- **코드 작성 문제**: 정확한 구문 작성 (각 7점)
- **총점**: 100점 (15문제 × 6.67점, 반올림 처리)

---

## 🔍 문제별 정답 및 상세 해설

### **문제 1** - 변수 선언과 호이스팅
**정답**: 1번 (undefined, 5)

**상세 해설**:
- `var` 키워드로 선언된 변수는 **호이스팅**됩니다.
- 실제로는 다음과 같이 동작합니다:
  ```javascript
  var x; // 선언부만 상단으로 호이스팅
  console.log(x); // undefined (선언은 됐지만 초기화 안됨)
  x = 5; // 초기화
  console.log(x); // 5
  ```
- `let`이나 `const`를 사용하면 TDZ(Temporal Dead Zone)로 인해 ReferenceError가 발생합니다.

**관련 개념**: 호이스팅, TDZ, var/let/const 차이점

---

### **문제 2** - typeof 연산자
**정답**: 2번 (typeof undefined)

**상세 해설**:
- `typeof null` → `"object"` (JavaScript의 유명한 버그)
- `typeof undefined` → `"undefined"`
- `typeof {}` → `"object"`
- `typeof []` → `"object"` (배열도 객체의 한 종류)
- 따라서 `typeof undefined`만 결과가 다릅니다.

**관련 개념**: typeof 연산자, 데이터 타입, null과 undefined의 차이

---

### **문제 3** - 함수 스코프와 클로저
**정답**: 1번 (10)

**상세 해설**:
- **클로저**의 핵심 개념입니다.
- 내부 함수 `inner`는 외부 함수 `outer`의 변수 `x`에 접근할 수 있습니다.
- `outer()` 함수가 종료되어도 `inner` 함수는 여전히 `x`를 참조할 수 있습니다.
- 이는 JavaScript의 **어휘적 스코핑(Lexical Scoping)** 때문입니다.

**관련 개념**: 클로저, 어휘적 스코핑, 함수 스코프

---

### **문제 4** - this 바인딩
**정답**: 2번 (undefined)

**상세 해설**:
- `obj.getName`을 변수 `fn`에 할당하면, 함수가 객체와의 연결을 잃습니다.
- `fn()`을 호출할 때 `this`는 전역 객체(브라우저에서는 window)를 가리킵니다.
- 전역 객체에는 `name` 속성이 없으므로 `undefined`가 반환됩니다.
- 이를 해결하려면 `bind()`, `call()`, `apply()` 메소드를 사용해야 합니다.

**관련 개념**: this 바인딩, 메소드 호출 vs 함수 호출, bind/call/apply

---

### **문제 5** - 배열 메소드
**정답**: 2번 ([6, 8, 10])

**상세 해설**:
- **메소드 체이닝**의 예시입니다.
- `arr.filter(x => x > 2)` → `[3, 4, 5]` (2보다 큰 요소만 필터링)
- `.map(x => x * 2)` → `[6, 8, 10]` (각 요소에 2를 곱함)
- `filter`와 `map`은 모두 새로운 배열을 반환하므로 원본 배열은 변경되지 않습니다.

**관련 개념**: 배열 메소드, 고차 함수, 메소드 체이닝, 불변성

---

### **문제 6** - 객체 참조
**정답**: 2번 (2)

**상세 해설**:
- 객체는 **참조 타입**입니다.
- `const obj2 = obj1`은 객체를 복사하는 것이 아니라 같은 객체를 참조합니다.
- 따라서 `obj2.a`를 변경하면 `obj1.a`도 함께 변경됩니다.
- 이는 **얕은 복사(Shallow Copy)**와 **깊은 복사(Deep Copy)**의 차이와 관련됩니다.

**관련 개념**: 참조 타입, 원시 타입, 얕은 복사, 깊은 복사

---

### **문제 7** - 템플릿 리터럴 (코드 작성)
**정답**: 
```javascript
const message = `안녕하세요, ${name} ${version}입니다!`;
```

**상세 해설**:
- **템플릿 리터럴**은 ES2015에서 도입된 문법입니다.
- 백틱(`)을 사용하여 문자열을 정의합니다.
- `${}`를 사용하여 변수나 표현식을 문자열에 삽입할 수 있습니다.
- 문자열 연결보다 가독성이 좋고 여러 줄 문자열도 쉽게 작성할 수 있습니다.

**관련 개념**: 템플릿 리터럴, 문자열 보간, ES2015 문법

---

### **문제 8** - 화살표 함수 (코드 작성)
**정답**: 
```javascript
const multiply = (a, b) => a * b;
```

**상세 해설**:
- **화살표 함수**는 ES2015에서 도입된 간결한 함수 문법입니다.
- `function` 키워드를 생략하고 `=>`를 사용합니다.
- 단일 표현식인 경우 `return`을 생략할 수 있습니다.
- 화살표 함수는 자체 `this`를 가지지 않습니다.

**다른 표현법들**:
```javascript
// 완전한 형태
const multiply = (a, b) => { return a * b; };

// 매개변수가 하나인 경우 괄호 생략 가능
const double = x => x * 2;
```

**관련 개념**: 화살표 함수, ES2015 문법, this 바인딩

---

### **문제 9** - 배열 구조분해 (코드 작성)
**정답**: 
```javascript
const [first, , third] = colors;
```

**상세 해설**:
- **구조분해 할당**은 ES2015에서 도입된 문법입니다.
- 배열의 요소를 개별 변수로 쉽게 추출할 수 있습니다.
- 쉼표를 사용하여 건너뛸 요소를 표시할 수 있습니다.
- 결과: `first = 'red'`, `third = 'blue'`

**다른 예시들**:
```javascript
// 기본값 설정
const [a = 1, b = 2] = [10];

// 나머지 요소 수집
const [head, ...tail] = [1, 2, 3, 4];

// 변수 교환
[a, b] = [b, a];
```

**관련 개념**: 구조분해 할당, ES2015 문법, 배열 패턴

---

### **문제 10** - 프로토타입과 상속
**정답**: 1번 (Buddy makes a sound)

**상세 해설**:
- **프로토타입 기반 상속**의 예시입니다.
- `Animal.call(this, name)`: Dog 생성자에서 Animal 생성자를 호출
- `Dog.prototype = Object.create(Animal.prototype)`: Dog가 Animal을 상속
- `Dog.prototype.constructor = Dog`: constructor 속성 복원
- `dog.speak()`는 Animal.prototype.speak 메소드를 사용합니다.

**상속 구조**:
```
dog (인스턴스)
├── Dog.prototype
    ├── Animal.prototype
        └── speak 메소드
```

**관련 개념**: 프로토타입 상속, 생성자 함수, Object.create, call 메소드

---

### **문제 11** - 엄격 모드
**정답**: 3번 (ReferenceError)

**상세 해설**:
- **엄격 모드('use strict')**에서는 더 엄격한 규칙이 적용됩니다.
- 선언되지 않은 변수에 값을 할당하면 ReferenceError가 발생합니다.
- 일반 모드에서는 암묵적으로 전역 변수가 생성되지만, 엄격 모드에서는 이를 금지합니다.

**엄격 모드의 다른 특징들**:
- 중복된 매개변수 이름 금지
- with 문 사용 금지
- eval의 스코프 격리
- this가 undefined일 때 전역 객체로 변환하지 않음

**관련 개념**: 엄격 모드, 스코프, 전역 변수

---

### **문제 12** - 즉시 실행 함수 (코드 작성)
**정답**: 
```javascript
(function() { 
    const x = 10; 
    return x; 
})();
```

**상세 해설**:
- **즉시 실행 함수(IIFE, Immediately Invoked Function Expression)**입니다.
- 함수를 정의함과 동시에 실행합니다.
- 전역 스코프를 오염시키지 않고 변수를 캡슐화할 수 있습니다.
- 모듈 패턴의 기초가 됩니다.

**다른 표현법들**:
```javascript
// 화살표 함수 버전
(() => {
    const x = 10;
    return x;
})();

// 매개변수가 있는 경우
(function(param) {
    return param * 2;
})(5);
```

**관련 개념**: IIFE, 스코프 캡슐화, 모듈 패턴

---

### **문제 13** - reduce 메소드 (코드 작성)
**정답**: 
```javascript
const sum = numbers.reduce((acc, cur) => acc + cur, 0);
```

**상세 해설**:
- **reduce 메소드**는 배열의 모든 요소를 하나의 값으로 축소합니다.
- 첫 번째 인자(acc): 누적값(accumulator)
- 두 번째 인자(cur): 현재값(current)
- 세 번째 인자(0): 초기값(initial value)

**동작 과정**:
1. acc = 0, cur = 1 → 0 + 1 = 1
2. acc = 1, cur = 2 → 1 + 2 = 3
3. acc = 3, cur = 3 → 3 + 3 = 6
4. acc = 6, cur = 4 → 6 + 4 = 10
5. acc = 10, cur = 5 → 10 + 5 = 15

**다른 활용 예시**:
```javascript
// 최댓값 찾기
const max = numbers.reduce((acc, cur) => Math.max(acc, cur));

// 객체 생성
const obj = arr.reduce((acc, cur) => {
    acc[cur] = cur * 2;
    return acc;
}, {});
```

**관련 개념**: reduce 메소드, 고차 함수, 함수형 프로그래밍

---

### **문제 14** - Object.keys와 Object.values
**정답**: 1번 (3, 6)

**상세 해설**:
- `Object.keys(obj)`는 객체의 **열거 가능한 속성 이름들**을 배열로 반환합니다.
- `Object.values(obj)`는 객체의 **열거 가능한 속성 값들**을 배열로 반환합니다.
- `Object.keys(obj)` → `['a', 'b', 'c']` → length = 3
- `Object.values(obj)` → `[1, 2, 3]` → reduce로 합계 = 6

**관련 메소드들**:
```javascript
// 키-값 쌍 배열 반환
Object.entries(obj); // [['a', 1], ['b', 2], ['c', 3]]

// 속성 개수 확인
Object.keys(obj).length; // 3

// 모든 값이 특정 조건을 만족하는지 확인
Object.values(obj).every(val => val > 0); // true
```

**관련 개념**: Object 메소드, 객체 순회, 열거 가능한 속성

---

### **문제 15** - 이벤트 루프 이해
**정답**: 2번 (1, 3, 2)

**상세 해설**:
- **이벤트 루프**와 **태스크 큐**의 동작 원리를 이해하는 문제입니다.
- 동기 코드가 먼저 실행되고, 비동기 코드는 나중에 실행됩니다.
- `setTimeout`은 0ms 후에 실행되지만, 여전히 비동기적으로 처리됩니다.

**실행 순서**:
1. `console.log('1')` - 동기 코드, 즉시 실행
2. `setTimeout(...)` - 비동기 코드, 태스크 큐에 등록
3. `console.log('3')` - 동기 코드, 즉시 실행
4. 콜스택이 비워진 후 태스크 큐의 콜백 실행: `console.log('2')`

**관련 개념**: 이벤트 루프, 콜스택, 태스크 큐, 동기/비동기 처리

---

## 📊 카테고리별 정답 분석

### **기본 문법 (3문제)**
- **문제 1**: 호이스팅 → 정답률 예상 70%
- **문제 2**: typeof 연산자 → 정답률 예상 60%
- **문제 11**: 엄격 모드 → 정답률 예상 50%

### **함수 (4문제)**
- **문제 3**: 클로저 → 정답률 예상 40%
- **문제 4**: this 바인딩 → 정답률 예상 30%
- **문제 8**: 화살표 함수 → 정답률 예상 80%
- **문제 12**: IIFE → 정답률 예상 60%

### **객체 (3문제)**
- **문제 10**: 프로토타입 상속 → 정답률 예상 35%
- **문제 14**: Object 메소드 → 정답률 예상 65%
- **문제 4**: this 바인딩 (중복) → 정답률 예상 30%

### **배열 (3문제)**
- **문제 5**: 메소드 체이닝 → 정답률 예상 75%
- **문제 9**: 구조분해 할당 → 정답률 예상 70%
- **문제 13**: reduce 메소드 → 정답률 예상 55%

### **고급 개념 (2문제)**
- **문제 6**: 객체 참조 → 정답률 예상 45%
- **문제 15**: 이벤트 루프 → 정답률 예상 40%

---

## 🎯 점수별 학습 상태 진단

### **90-100점 (A등급)**
- **상태**: 모든 핵심 개념을 완벽히 이해하고 있음
- **특징**: 기본 문법부터 고급 개념까지 전반적으로 우수
- **다음 단계**: 실제 프로젝트 개발, 프레임워크 학습

### **80-89점 (B등급)**
- **상태**: 대부분의 개념을 잘 이해하고 있음
- **특징**: 기본기는 탄탄하나 일부 고급 개념 보완 필요
- **다음 단계**: 틀린 문제 영역 집중 학습, 실습 문제 풀이

### **70-79점 (C등급)**
- **상태**: 기본적인 개념은 이해하고 있음
- **특징**: 응용 문제나 복합 개념에서 어려움
- **다음 단계**: 함수, 객체, 배열 메소드 반복 학습

### **60-69점 (D등급)**
- **상태**: 기초적인 이해는 있으나 전반적으로 부족
- **특징**: 기본 문법은 알지만 심화 개념 미흡
- **다음 단계**: 1~13차시 전체 복습, 개념 재정리

### **60점 미만 (F등급)**
- **상태**: 기초 개념부터 다시 학습 필요
- **특징**: 전반적인 이해도 부족
- **다음 단계**: 기초 문법부터 차근차근 재학습

---

## 💡 오답 유형별 학습 가이드

### **개념 이해 부족**
- **증상**: 용어의 정확한 의미를 모르거나 헷갈림
- **해결책**: 용어 정리, 예제 코드 직접 실행해보기

### **응용 능력 부족**
- **증상**: 개념은 알지만 실제 문제에 적용하지 못함
- **해결책**: 다양한 문제 풀이, 코드 작성 연습

### **실행 결과 예측 실패**
- **증상**: 코드가 어떻게 동작할지 예측하지 못함
- **해결책**: 코드 한 줄씩 따라가며 실행 과정 이해

### **문법 오류**
- **증상**: 올바른 문법을 작성하지 못함
- **해결책**: 기본 문법 반복 학습, 타이핑 연습

---

## 🔍 추가 학습 자료

### **복습이 필요한 개념들**
1. **호이스팅과 TDZ**: var, let, const의 차이점 명확히 이해
2. **클로저**: 실제 예제를 통한 동작 원리 파악
3. **this 바인딩**: 다양한 상황에서의 this 값 예측 연습
4. **프로토타입**: 상속 구조와 메소드 체이닝 이해
5. **이벤트 루프**: 비동기 처리 과정 시각화하여 이해

### **실습 과제**
1. 클로저를 활용한 카운터 함수 만들기
2. 프로토타입을 이용한 간단한 클래스 구현
3. 배열 메소드를 활용한 데이터 처리 함수 작성
4. 템플릿 리터럴을 이용한 HTML 템플릿 생성
5. 이벤트 루프를 고려한 비동기 코드 작성

---

**🎓 학습 완료 후 다음 단계**: 14차시부터 계속 진행하여 DOM 조작, 이벤트 처리, 비동기 프로그래밍 등 실무 활용 기술을 학습하세요!