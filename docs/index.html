<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 학습 가이드</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>

    <div class="container">
        <button id="menu-toggle">☰</button>
        <aside id="sidebar">
            <h2>목차</h2>
            <ul id="toc">
                <!-- Table of Contents will be generated here by JS -->
            </ul>
        </aside>

        <main id="presentation">
            <div id="slides-container">

                <!-- Slide 0: Title -->
                <section class="slide title-slide" id="title">
                    <div class="slide-content">
                        <h1>JavaScript 학습 가이드</h1>
                        <h2>웹 개발의 핵심 언어 마스터하기</h2>
                        <p style="margin-top: 50px;">사이드바 또는 키보드 방향키를 사용하여 탐색하세요.</p>
                    </div>
                </section>
                
                <!-- Slide 1: 01-tutorial 튜토리얼: 기본 문법 -->
                <section class="slide" id="tutorial-basic">
                    <div class="slide-content">
                        <h1>튜토리얼: 기본 문법</h1>
                        <h3>기본 규칙</h3>
                        <table>
                            <tr><th>규칙</th><th>설명</th><th>예제</th></tr>
                            <tr>
                                <td><strong>대소문자 구분</strong></td>
                                <td>모든 부분에서 대소문자를 구분함</td>
                                <td><code>function</code>과 <code>Function</code>은 다름</td>
                            </tr>
                            <tr>
                                <td><strong>세미콜론</strong></td>
                                <td>구문을 구분하는 구분자. 줄바꿈으로 대체 가능하지만 명시적 사용을 권장.</td>
                                <td><code>const a = 1;</code></td>
                            </tr>
                            <tr>
                                <td><strong>공백</strong></td>
                                <td>공백 수는 실행에 영향 없음 (가독성을 위해 사용)</td>
                                <td><code>const x = 1;</code></td>
                            </tr>
                        </table>
                        
                        <h3>주석 (Comment)</h3>
                        <pre><code class="language-javascript">
// 이것은 한 줄 주석입니다.

/*
이것은
여러 줄에 걸친
주석입니다.
*/
                        </code></pre>
                        
                        <h3>값(value)과 리터럴(literal)</h3>
                        <p>리터럴은 코드에 값을 직접 표현하는 방식입니다.</p>
                        <pre><code class="language-javascript">
1 // 정수 리터럴
2.5 // 부동소수점 실수 리터럴
'hello world' // 작은 따옴표 문자열 리터럴
"JavaScript" // 큰 따옴표 문자열 리터럴
true // 참(true)을 나타내는 진리값 리터럴
false // 거짓(false)을 나타내는 진리값 리터럴
null // '존재하지 않음'을 나타내는 값
undefined // '정의된 적 없음'을 나타내는 값
                        </code></pre>
                    </div>
                </section>
                
                <!-- Slide 2: 02-javascript-intro JavaScript 소개 -->
                <section class="slide" id="intro">
                    <div class="slide-content">
                        <h1>JavaScript 소개</h1>
                        <h3>JavaScript의 탄생과 역사</h3>
                        <table>
                            <tr>
                                <th>연도</th>
                                <th>사건</th>
                                <th>설명</th>
                            </tr>
                            <tr>
                                <td><strong>1995년</strong></td>
                                <td>JavaScript 탄생</td>
                                <td>Netscape Navigator에 최초 탑재</td>
                            </tr>
                            <tr>
                                <td><strong>마케팅</strong></td>
                                <td>Java와 유사한 이름</td>
                                <td>실제로는 Java와 다른 언어, "햄과 햄스터의 관계"</td>
                            </tr>
                        </table>

                        <h3>언어 vs 구동 환경</h3>
                        <table>
                            <tr><th>구분</th><th>역할</th><th>예시</th></tr>
                            <tr>
                                <td><strong>JavaScript 언어</strong></td>
                                <td>코드 실행 관련 기능</td>
                                <td>변수, 함수, 객체 등</td>
                            </tr>
                            <tr>
                                <td><strong>구동 환경</strong></td>
                                <td>입출력 관련 기능</td>
                                <td>브라우저(alert), Node.js(fs), 게임 엔진</td>
                            </tr>
                        </table>
                        
                        <h3>ECMAScript와 브라우저 호환성</h3>
                        <p>JavaScript의 표준 명세를 <strong>ECMAScript</strong>라고 합니다. 브라우저 제조사들은 이 표준을 따라 기능을 구현합니다.</p>
                        <ul>
                            <li><strong>ES5 (2009)</strong>: 브라우저 호환성 개선</li>
                            <li><strong>ES2015 (ES6)</strong>: 클래스, 모듈, 화살표 함수 등 대규모 업데이트</li>
                            <li><strong>ES2016+</strong>: 매년 새로운 기능 추가</li>
                        </ul>
                        
                        <h3>트랜스파일러와 폴리필</h3>
                        <ul>
                            <li><strong>트랜스파일러 (Transpiler)</strong>: 최신 문법을 구형 브라우저가 이해할 수 있는 코드로 변환 (예: Babel)</li>
                            <li><strong>폴리필 (Polyfill)</strong>: 구형 브라우저에 없는 새로운 기능을 구현한 코드 조각 (예: `Array.prototype.includes`)</li>
                        </ul>
                    </div>
                </section>
                
                <!-- Slide 3: 03-value-variable-type 튜토리얼: 변수와 타입 -->
                <section class="slide" id="tutorial-vars">
                    <div class="slide-content">
                        <h1>튜토리얼: 변수와 타입</h1>
                        <h3>변수 (Variable)</h3>
                        <p>값을 재사용하기 위해 이름(식별자)을 붙여 저장하는 공간입니다.</p>
                        <table>
                            <tr><th>키워드</th><th>설명</th><th>재할당</th><th>권장사항</th></tr>
                            <tr><td><strong><code>const</code></strong></td><td>변경 불가능한 상수</td><td>❌</td><td>기본적으로 사용</td></tr>
                            <tr><td><strong><code>let</code></strong></td><td>변경 가능한 변수</td><td>⭕</td><td>재할당이 필요한 경우에만 사용</td></tr>
                        </table>
                        <pre><code class="language-javascript">
// 변수 선언과 할당
const PI = 3.14;
let score = 90;

score = 95; // let은 재할당 가능
// PI = 3.14159; // 에러! const는 재할당 불가
                        </code></pre>
                        
                        <h3>값의 타입(type)</h3>
                        <p><code>typeof</code> 연산자로 값의 타입을 확인할 수 있습니다.</p>
                        <pre><code class="language-javascript">
typeof 1;          // 'number'
typeof 'hello';    // 'string'
typeof true;       // 'boolean'
typeof undefined;  // 'undefined'
typeof null;       // 'object' (언어의 오래된 버그)
typeof {};         // 'object'
typeof [];         // 'object'
typeof function(){}; // 'function'
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 4: 04-number-type Number 타입 -->
                <section class="slide" id="number">
                    <div class="slide-content">
                        <h1>Number 타입</h1>
                        <h3>숫자 리터럴</h3>
                        <table>
                            <tr><th>진법</th><th>표기법</th><th>예시</th><th>설명</th></tr>
                            <tr><td><strong>10진법</strong></td><td>그대로</td><td><code>123, 3.14</code></td><td>일반적인 숫자 표기</td></tr>
                            <tr><td><strong>2진법</strong></td><td><code>0b</code> 또는 <code>0B</code></td><td><code>0b1010</code></td><td>2진수 (ES6)</td></tr>
                            <tr><td><strong>8진법</strong></td><td><code>0o</code> 또는 <code>0O</code></td><td><code>0o777</code></td><td>8진수 (ES6)</td></tr>
                            <tr><td><strong>16진법</strong></td><td><code>0x</code> 또는 <code>0X</code></td><td><code>0xFF</code></td><td>16진수</td></tr>
                        </table>
                        
                        <h3>산술 연산자</h3>
                        <p><code>+</code> (덧셈), <code>-</code> (뺄셈), <code>*</code> (곱셈), <code>/</code> (나눗셈), <code>%</code> (나머지), <code>**</code> (거듭제곱)</p>
                        
                        <h3>부동 소수점 문제</h3>
                        <p>컴퓨터는 2진법으로 소수를 표현하기 때문에 10진수 소수 계산에 미세한 오차가 발생할 수 있습니다.</p>
                        <pre><code class="language-javascript">
0.1 + 0.2; // 결과: 0.30000000000000004
0.1 + 0.2 === 0.3; // false
                        </code></pre>

                        <h3>특수한 숫자 값</h3>
                        <ul>
                            <li><strong><code>Infinity</code></strong>: 양의 무한대 (예: <code>1 / 0</code>)</li>
                            <li><strong><code>-Infinity</code></strong>: 음의 무한대 (예: <code>-1 / 0</code>)</li>
                            <li><strong><code>NaN</code></strong>: Not a Number (숫자가 아님). 계산 불가능한 연산의 결과. (예: <code>'a' * 2</code>)</li>
                        </ul>
                        <p><strong>주의:</strong> <code>NaN</code>은 자기 자신과도 같지 않습니다 (<code>NaN === NaN</code>은 <code>false</code>). <code>Number.isNaN()</code>을 사용해 확인해야 합니다.</p>
                    </div>
                </section>

                <!-- Slide 5: 05-string-type String 타입 -->
                <section class="slide" id="string">
                    <div class="slide-content">
                        <h1>String 타입</h1>
                        <h3>문자열 생성</h3>
                        <p>작은따옴표(<code>'</code>), 큰따옴표(<code>"</code>), 백틱(<code>`</code>)으로 문자열을 만들 수 있습니다.</p>
                        
                        <h3>템플릿 리터럴 (Template Literal)</h3>
                        <p>백틱(<code>`</code>)을 사용하여 문자열 내부에 변수나 표현식을 쉽게 삽입할 수 있습니다.</p>
                        <pre><code class="language-javascript">
const name = 'JavaScript';
const greeting = `Hello, ${name}!`; // "Hello, JavaScript!"

const multiLine = `이것은
여러 줄에 걸친
문자열입니다.`;
                        </code></pre>
                        
                        <h3>주요 메소드</h3>
                        <table>
                            <tr><th>메소드</th><th>설명</th><th>예제</th></tr>
                            <tr><td><code>.length</code></td><td>문자열 길이</td><td><code>'hello'.length // 5</code></td></tr>
                            <tr><td><code>.toUpperCase()</code></td><td>대문자로 변환</td><td><code>'js'.toUpperCase() // 'JS'</code></td></tr>
                            <tr><td><code>.toLowerCase()</code></td><td>소문자로 변환</td><td><code>'JS'.toLowerCase() // 'js'</code></td></tr>
                            <tr><td><code>.includes('sub')</code></td><td>부분 문자열 포함 여부</td><td><code>'abc'.includes('b') // true</code></td></tr>
                            <tr><td><code>.slice(start, end)</code></td><td>문자열 자르기</td><td><code>'abcde'.slice(1, 3) // 'bc'</code></td></tr>
                            <tr><td><code>.replace('a', 'b')</code></td><td>문자열 치환 (첫 번째)</td><td><code>'hello'.replace('l', 'x') // 'hexlo'</code></td></tr>
                            <tr><td><code>.split('sep')</code></td><td>문자열을 배열로 분리</td><td><code>'a,b,c'.split(',') // ['a', 'b', 'c']</code></td></tr>
                            <tr><td><code>.trim()</code></td><td>양쪽 공백 제거</td><td><code>'  hi  '.trim() // 'hi'</code></td></tr>
                        </table>
                    </div>
                </section>

                <!-- Slide 6: 06-boolean-type Boolean 타입 -->
                <section class="slide" id="boolean">
                    <div class="slide-content">
                        <h1>Boolean 타입</h1>
                        <p>참(<code>true</code>) 또는 거짓(<code>false</code>)을 나타내는 타입입니다.</p>
                        
                        <h3>논리 연산자</h3>
                        <table>
                            <tr><th>연산자</th><th>이름</th><th>설명</th><th>예제</th></tr>
                            <tr><td><strong><code>&&</code></strong></td><td>논리곱 (AND)</td><td>모두 참일 때만 참</td><td><code>true && false // false</code></td></tr>
                            <tr><td><strong><code>||</code></strong></td><td>논리합 (OR)</td><td>하나라도 참이면 참</td><td><code>true || false // true</code></td></tr>
                            <tr><td><strong><code>!</code></strong></td><td>논리부정 (NOT)</td><td>참과 거짓을 뒤바꿈</td><td><code>!true // false</code></td></tr>
                        </table>
                        
                        <h3>Truthy와 Falsy</h3>
                        <p>JavaScript에서는 <code>if</code>문 등에서 불린 값이 아니더라도 참 또는 거짓으로 평가될 수 있습니다.</p>
                        
                        <h4>Falsy (거짓으로 취급되는 값)</h4>
                        <ul>
                            <li><code>false</code></li>
                            <li><code>0</code>, <code>-0</code>, <code>0n</code></li>
                            <li><code>""</code> (빈 문자열)</li>
                            <li><code>null</code></li>
                            <li><code>undefined</code></li>
                            <li><code>NaN</code></li>
                        </ul>
                        <p><strong>이 외의 모든 값은 Truthy(참으로 취급)입니다.</strong> (예: <code>[]</code>, <code>{}</code>, <code>'false'</code>)</p>
                        
                        <h3>단축 평가 (Short-circuit Evaluation)</h3>
                        <p>논리 연산은 왼쪽부터 평가하며, 결과가 확정되면 오른쪽은 평가하지 않습니다.</p>
                        <pre><code class="language-javascript">
// user가 존재할 때만 user.name을 출력
user && console.log(user.name);

// name이 falsy(빈 문자열 등)일 경우 'Guest'를 할당
const displayName = name || 'Guest';
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 7: 07-null-undefined null과 undefined -->
                <section class="slide" id="null-undefined">
                    <div class="slide-content">
                        <h1>null과 undefined</h1>
                        <p>두 값 모두 '값이 없음'을 나타내지만, 미묘한 차이가 있습니다.</p>
                        
                        <h3>undefined</h3>
                        <ul>
                            <li>시스템이 자동으로 부여하는 값</li>
                            <li>변수를 선언만 하고 값을 할당하지 않은 경우</li>
                            <li>객체에 존재하지 않는 속성에 접근하려는 경우</li>
                            <li>함수가 아무것도 반환하지 않을 때</li>
                        </ul>
                        <pre><code class="language-javascript">
let a;
console.log(a); // undefined

const obj = {};
console.log(obj.nonExistent); // undefined
                        </code></pre>
                        
                        <h3>null</h3>
                        <ul>
                            <li>개발자가 의도적으로 '값이 없음'을 명시할 때 사용</li>
                            <li>'비어있는 객체'를 의도적으로 나타낼 때 주로 사용</li>
                        </ul>
                        <pre><code class="language-javascript">
let b = null;
console.log(b); // null
                        </code></pre>

                        <h3>비교와 Null Check</h3>
                        <table>
                            <tr><th>비교</th><th>결과</th><th>설명</th></tr>
                            <tr><td><code>null == undefined</code></td><td><code>true</code></td><td>동등 연산자(<code>==</code>)는 타입을 변환하여 비교하므로 같다고 판단.</td></tr>
                            <tr><td><code>null === undefined</code></td><td><code>false</code></td><td>일치 연산자(<code>===</code>)는 타입까지 비교하므로 다르다고 판단.</td></tr>
                        </table>
                        
                        <p>값이 <code>null</code> 또는 <code>undefined</code> 인지 확인할 때 (Null Check) <code>==</code> 연산자가 유용하게 쓰일 수 있습니다.</p>
                        <pre><code class="language-javascript">
function printValue(value) {
  // value가 null이거나 undefined가 아닐 때만 출력
  if (value != null) {
    console.log(value);
  }
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 8: 08-function 튜토리얼: 함수, 객체, 배열 -->
                <section class="slide" id="tutorial-func-obj-arr">
                    <div class="slide-content">
                        <h1>튜토리얼: 함수, 객체, 배열</h1>
                        <h3>함수 (Function)</h3>
                        <p>코드 뭉치에 이름을 붙여 재사용하는 기능 단위입니다.</p>
                        <pre><code class="language-javascript">
// 함수 선언
function add(x, y) {
  return x + y;
}

// 화살표 함수 (ES2015)
const multiply = (x, y) => x * y;

// 함수 호출
console.log(add(3, 5));      // 8
console.log(multiply(3, 5)); // 15
                        </code></pre>
                        
                        <h3>객체 (Object)</h3>
                        <p>이름(key)과 값(value)으로 구성된 속성(property)들의 집합입니다.</p>
                        <pre><code class="language-javascript">
const person = {
  name: '김개발',
  age: 28,
  greet() {
    return `안녕하세요, ${this.name}입니다!`;
  }
};
console.log(person.name); // '김개발'
console.log(person.greet()); // "안녕하세요, 김개발입니다!"
                        </code></pre>
                        
                        <h3>배열 (Array)</h3>
                        <p>순서가 있는 값들의 목록입니다. 인덱스는 0부터 시작합니다.</p>
                        <pre><code class="language-javascript">
const fruits = ['apple', 'banana', 'orange'];
console.log(fruits[0]); // 'apple'
console.log(fruits.length); // 3

fruits.push('grape'); // 끝에 요소 추가
console.log(fruits); // ['apple', 'banana', 'orange', 'grape']
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 9: 09-control-statement 튜토리얼: 제어 흐름 -->
                <section class="slide" id="tutorial-control">
                    <div class="slide-content">
                        <h1>튜토리얼: 제어 흐름</h1>
                        <h3>조건문 (if...else)</h3>
                        <p>특정 조건을 만족할 때만 코드를 실행합니다.</p>
                        <pre><code class="language-javascript">
const score = 85;
if (score >= 90) {
  console.log('A 학점');
} else if (score >= 80) {
  console.log('B 학점');
} else {
  console.log('C 학점 이하');
}
                        </code></pre>
                        
                        <h3>반복문 (while, for)</h3>
                        <p>코드를 여러 번 반복해서 실행합니다.</p>
                        <pre><code class="language-javascript">
// for 반복문 (횟수 기반)
for (let i = 0; i < 3; i++) {
  console.log(`${i + 1}번째 실행`);
}

// while 반복문 (조건 기반)
let count = 0;
while (count < 3) {
  console.log(`반복 ${count}`);
  count++;
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 10: 10-object 객체 -->
                <section class="slide" id="data-types">
                    <div class="slide-content">
                        <h1>JavaScript 데이터 타입</h1>
                        <h3>원시 타입 (Primitive Types)</h3>
                        <table>
                            <tr><th>타입</th><th>설명</th><th>예제</th></tr>
                            <tr><td><code>string</code></td><td>문자열</td><td><code>'Hello', "World", `Template`</code></td></tr>
                            <tr><td><code>number</code></td><td>숫자 (정수, 실수)</td><td><code>42, 3.14, NaN, Infinity</code></td></tr>
                            <tr><td><code>boolean</code></td><td>참/거짓</td><td><code>true, false</code></td></tr>
                            <tr><td><code>undefined</code></td><td>값이 할당되지 않음</td><td><code>let x; // x는 undefined</code></td></tr>
                            <tr><td><code>null</code></td><td>의도적인 빈 값</td><td><code>let data = null;</code></td></tr>
                            <tr><td><code>symbol</code></td><td>고유한 식별자</td><td><code>Symbol('id')</code></td></tr>
                            <tr><td><code>bigint</code></td><td>큰 정수</td><td><code>123n, BigInt(123)</code></td></tr>
                        </table>
                        
                        <h3>참조 타입 (Reference Type)</h3>
                        <pre><code class="language-javascript">
// 객체 (Object)
const person = {
  name: '김개발',
  age: 30,
  isEmployed: true
};

// 배열 (Array)
const numbers = [1, 2, 3, 4, 5];
const mixed = ['문자열', 42, true, null];

// 함수 (Function)
function greet(name) {
  return `안녕하세요, ${name}님!`;
}

// 날짜 (Date)
const now = new Date();
const birthday = new Date('1990-01-01');
                        </code></pre>
                        
                        <h3>타입 확인 방법</h3>
                        <pre><code class="language-javascript">
// typeof 연산자
console.log(typeof 'hello'); // 'string'
console.log(typeof 42); // 'number'
console.log(typeof true); // 'boolean'
console.log(typeof undefined); // 'undefined'
console.log(typeof null); // 'object' (주의!)
console.log(typeof []); // 'object'
console.log(typeof {}); // 'object'

// 더 정확한 타입 확인
console.log(Array.isArray([])); // true
console.log(Object.prototype.toString.call(null)); // '[object Null]'
                        </code></pre>
                        
                        <h3>타입 변환</h3>
                        <pre><code class="language-javascript">
// 명시적 변환
String(123); // '123'
Number('123'); // 123
Boolean(0); // false

// 암시적 변환
'5' + 3; // '53' (문자열 연결)
'5' - 3; // 2 (숫자 계산)
!!'hello'; // true (불린 변환)
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 11: 11-array 배열과 유용한 메서드 -->
                <section class="slide" id="arrays">
                    <div class="slide-content">
                        <h1>배열과 유용한 메서드</h1>
                        <h3>배열 기본 메서드</h3>
                        <table>
                            <tr><th>메서드</th><th>설명</th><th>반환값</th></tr>
                            <tr><td><code>push()</code></td><td>끝에 요소 추가</td><td>새로운 length</td></tr>
                            <tr><td><code>pop()</code></td><td>끝 요소 제거</td><td>제거된 요소</td></tr>
                            <tr><td><code>shift()</code></td><td>첫 요소 제거</td><td>제거된 요소</td></tr>
                            <tr><td><code>unshift()</code></td><td>앞에 요소 추가</td><td>새로운 length</td></tr>
                        </table>
                        
                        <h3>고차 함수 메서드</h3>
                        <pre><code class="language-javascript">
const numbers = [1, 2, 3, 4, 5];

// map: 각 요소를 변환
const doubled = numbers.map(n => n * 2); 
console.log(doubled); // [2, 4, 6, 8, 10]

// filter: 조건에 맞는 요소만으로 새 배열 생성
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens); // [2, 4]

// reduce: 누적 계산
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15

// find: 조건에 맞는 첫 번째 요소
const found = numbers.find(n => n > 3);
console.log(found); // 4

// some: 하나라도 조건을 만족하는지
const hasEven = numbers.some(n => n % 2 === 0);
console.log(hasEven); // true

// every: 모든 요소가 조건을 만족하는지
const allPositive = numbers.every(n => n > 0);
console.log(allPositive); // true
                        </code></pre>
                        
                        <h3>실용적인 예제</h3>
                        <pre><code class="language-javascript">
const users = [
  { name: '김철수', age: 25, city: '서울' },
  { name: '이영희', age: 30, city: '부산' },
  { name: '박민수', age: 35, city: '서울' }
];

// 서울 거주자만 필터링
const seoulUsers = users.filter(user => user.city === '서울');

// 이름만 추출
const names = users.map(user => user.name);

// 평균 나이 계산
const avgAge = users.reduce((sum, user) => sum + user.age, 0) / users.length;

// 30세 이상인 사용자 찾기
const over30 = users.find(user => user.age >= 30);

// 배열 정렬
const sortedByAge = users.sort((a, b) => a.age - b.age);
                        </code></pre>
                        
                        <h3>ES6+ 배열 메서드</h3>
                        <pre><code class="language-javascript">
// flatMap: map + flat
const nested = [[1, 2], [3, 4], [5, 6]];
const flattened = nested.flatMap(arr => arr);
console.log(flattened); // [1, 2, 3, 4, 5, 6]

// includes: 요소 포함 여부
console.log(numbers.includes(3)); // true

// Array.from: 유사 배열을 배열로 변환
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const realArray = Array.from(arrayLike);
console.log(realArray); // ['a', 'b']
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 12: 12-value-in-depth 값 더 알아보기 -->
                <section class="slide" id="value-in-depth">
                    <div class="slide-content">
                        <h1>값 더 알아보기</h1>
                        <h3>let, const와 블록 스코프</h3>
                        <table>
                            <tr><th>특징</th><th>let/const</th><th>var</th></tr>
                            <tr><td><strong>재선언</strong></td><td>불허</td><td>허용</td></tr>
                            <tr><td><strong>호이스팅</strong></td><td>선언 전 사용 불가</td><td>undefined로 초기화</td></tr>
                            <tr><td><strong>스코프</strong></td><td>블록 스코프</td><td>함수 스코프</td></tr>
                        </table>
                        
                        <h3>참조 (Reference)</h3>
                        <pre><code class="language-javascript">
// 원시 타입: 값 자체가 복사됨
let a = 1;
let b = a;
a = 2;
console.log(b); // 1 (변경되지 않음)

// 참조 타입: 참조(주소)가 복사됨
let obj1 = { prop: 1 };
let obj2 = obj1;
obj1.prop = 2;
console.log(obj2.prop); // 2 (함께 변경됨)
                        </code></pre>
                        
                        <h3>스코프 체인</h3>
                        <p>안쪽 스코프에서 바깥쪽 스코프의 변수에 접근 가능하지만, 반대는 불가능합니다.</p>
                        <pre><code class="language-javascript">
let global = 'global';

function outer() {
  let outerVar = 'outer';
  
  function inner() {
    let innerVar = 'inner';
    console.log(global, outerVar, innerVar); // 모두 접근 가능
  }
  
  inner();
}
                        </code></pre>
                        
                        <h3>변수 사용 권장사항</h3>
                        <ol>
                            <li><strong>const 우선 사용</strong>: 재대입이 필요 없을 때</li>
                            <li><strong>let 차선 사용</strong>: 재대입이 필요할 때</li>
                            <li><strong>var 사용 금지</strong>: 예상치 못한 동작 가능성</li>
                        </ol>
                    </div>
                </section>

                <!-- Slide 13: 13-function-in-depth 함수 더 알아보기 -->
                <section class="slide" id="function-in-depth">
                    <div class="slide-content">
                        <h1>함수 더 알아보기</h1>
                        <h3>함수 정의 방법</h3>
                        <table>
                            <tr><th>방법</th><th>문법</th><th>특징</th></tr>
                            <tr><td><strong>함수 선언문</strong></td><td><code>function add() {}</code></td><td>호이스팅 됨</td></tr>
                            <tr><td><strong>함수 표현식</strong></td><td><code>const add = function() {}</code></td><td>호이스팅 안됨</td></tr>
                            <tr><td><strong>화살표 함수</strong></td><td><code>const add = () => {}</code></td><td>this 바인딩 없음</td></tr>
                        </table>
                        
                        <h3>클로저 (Closure)</h3>
                        <p>함수와 그 함수가 선언된 렉시컬 환경의 조합입니다.</p>
                        <pre><code class="language-javascript">
function createCounter() {
  let count = 0;
  
  return {
    increment() {
      count++;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.getCount()); // 1
                        </code></pre>
                        
                        <h3>this 바인딩</h3>
                        <ul>
                            <li><strong>일반 함수</strong>: 호출한 객체</li>
                            <li><strong>화살표 함수</strong>: 상위 스코프의 this</li>
                            <li><strong>메서드</strong>: 메서드가 속한 객체</li>
                            <li><strong>생성자</strong>: 새로 생성된 인스턴스</li>
                        </ul>
                        
                        <h3>고차 함수</h3>
                        <p>함수를 인수로 받거나 함수를 반환하는 함수입니다.</p>
                        <pre><code class="language-javascript">
function createMultiplier(factor) {
  return function(x) {
    return x * factor;
  };
}

const double = createMultiplier(2);
console.log(double(5)); // 10
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 14: 14-object-in-depth 객체 더 알아보기 -->
                <section class="slide" id="object-in-depth">
                    <div class="slide-content">
                        <h1>객체 더 알아보기</h1>
                        <h3>속성 접근법</h3>
                        <table>
                            <tr><th>방법</th><th>문법</th><th>사용 시기</th></tr>
                            <tr><td><strong>점 표기법</strong></td><td><code>obj.name</code></td><td>유효한 식별자인 경우</td></tr>
                            <tr><td><strong>대괄호 표기법</strong></td><td><code>obj['name']</code></td><td>특수문자가 있거나 변수를 사용하는 경우</td></tr>
                        </table>
                        
                        <h3>생성자 함수</h3>
                        <pre><code class="language-javascript">
function Person(name, age) {
  this.name = name;
  this.age = age;
  
  this.greet = function() {
    console.log(`안녕하세요, ${this.name}입니다.`);
  };
}

const alice = new Person('Alice', 30);
alice.greet(); // "안녕하세요, Alice입니다."
                        </code></pre>
                        
                        <h3>프로토타입 체인</h3>
                        <pre><code class="language-javascript">
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} makes a sound`);
};

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const myDog = new Dog('Buddy', 'Golden Retriever');
myDog.speak(); // "Buddy makes a sound"
                        </code></pre>
                        
                        <h3>캡슐화 예제</h3>
                        <pre><code class="language-javascript">
function BankAccount(balance) {
  let _balance = balance; // 프라이빗 변수
  
  return {
    deposit(amount) {
      if (amount > 0) _balance += amount;
    },
    getBalance() {
      return _balance;
    }
  };
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 15: 15-operator-in-depth 연산자 심화 -->
                <section class="slide" id="operator-in-depth">
                    <div class="slide-content">
                        <h1>연산자 심화</h1>
                        <h3>단축 평가 (Short-circuit Evaluation)</h3>
                        <p>논리 연산자들은 양쪽 피연산자를 모두 평가하지 않아도 결과를 결정할 수 있는 경우, 불필요한 평가를 생략합니다.</p>
                        <table>
                            <tr><th>연산자</th><th>동작</th><th>예제</th></tr>
                            <tr><td><code>&&</code></td><td>왼쪽이 falsy면 왼쪽 값 반환, 아니면 오른쪽 값 반환</td><td><code>false && expression</code></td></tr>
                            <tr><td><code>||</code></td><td>왼쪽이 truthy면 왼쪽 값 반환, 아니면 오른쪽 값 반환</td><td><code>true || expression</code></td></tr>
                            <tr><td><code>??</code></td><td>왼쪽이 null/undefined가 아니면 왼쪽 값 반환</td><td><code>null ?? 'default'</code></td></tr>
                        </table>
                        
                        <h3>실용적인 활용 예제</h3>
                        <pre><code class="language-javascript">
// if문을 대신하는 단축 평가
user && console.log(user.name);

// 기본값 설정
const displayName = name || 'Guest';
const username = user?.name ?? 'Anonymous';

// 옵셔널 체이닝 (ES2020)
const address = user?.profile?.address?.street;
                        </code></pre>
                        
                        <h3>Optional Chaining (?.) 연산자</h3>
                        <p>중첩된 객체의 속성에 안전하게 접근할 수 있게 해주는 ES2020 문법입니다.</p>
                        <pre><code class="language-javascript">
const person = {
  name: '김개발',
  company: {
    name: 'Tech Corp'
    // office 정보가 없음
  }
};

// 안전한 접근 (에러 없이 undefined 반환)
const officeAddress = person.company?.office?.address;
console.log(officeAddress); // undefined

// 기본값과 함께 사용
const address = person.company?.office?.address ?? '주소 정보 없음';
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 16: 16-builtins 내장 객체 -->
                <section class="slide" id="builtins">
                    <div class="slide-content">
                        <h1>내장 객체</h1>
                        <h3>Object 정적 메서드</h3>
                        <table>
                            <tr><th>메서드</th><th>설명</th><th>예제</th></tr>
                            <tr><td><code>Object.keys()</code></td><td>객체의 키들을 배열로 반환</td><td><code>Object.keys({a: 1, b: 2}) // ['a', 'b']</code></td></tr>
                            <tr><td><code>Object.values()</code></td><td>객체의 값들을 배열로 반환</td><td><code>Object.values({a: 1, b: 2}) // [1, 2]</code></td></tr>
                            <tr><td><code>Object.entries()</code></td><td>키-값 쌍을 배열로 반환</td><td><code>Object.entries({a: 1}) // [['a', 1]]</code></td></tr>
                            <tr><td><code>Object.assign()</code></td><td>객체 병합</td><td><code>Object.assign({}, a, b)</code></td></tr>
                        </table>
                        
                        <h3>Array 정적 메서드</h3>
                        <pre><code class="language-javascript">
// Array.from(): 유사 배열을 실제 배열로 변환
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const realArray = Array.from(arrayLike);
console.log(realArray); // ['a', 'b']

// Array.isArray(): 배열 여부 확인
Array.isArray([1, 2, 3]); // true
Array.isArray('hello'); // false

// Array.of(): 인수들로 배열 생성
Array.of(1, 2, 3); // [1, 2, 3]
                        </code></pre>
                        
                        <h3>Date 객체</h3>
                        <pre><code class="language-javascript">
// 현재 날짜와 시간
const now = new Date();

// 특정 날짜 생성
const birthday = new Date('1990-01-01');
const specificDate = new Date(2023, 11, 25); // 2023년 12월 25일

// 날짜 메서드
now.getFullYear(); // 연도
now.getMonth(); // 월 (0부터 시작)
now.getDate(); // 일
now.getDay(); // 요일 (0: 일요일)
                        </code></pre>
                        
                        <h3>Math 객체</h3>
                        <pre><code class="language-javascript">
Math.PI; // 3.141592653589793
Math.abs(-5); // 5 (절댓값)
Math.round(4.7); // 5 (반올림)
Math.floor(4.7); // 4 (내림)
Math.ceil(4.2); // 5 (올림)
Math.max(1, 3, 2); // 3
Math.min(1, 3, 2); // 1
Math.random(); // 0과 1 사이의 랜덤 수

// 1-10 사이 랜덤 정수
Math.floor(Math.random() * 10) + 1;
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 17: 17-fp 함수형 프로그래밍 -->
                <section class="slide" id="functional-programming">
                    <div class="slide-content">
                        <h1>함수형 프로그래밍</h1>
                        <h3>함수형 프로그래밍 원칙</h3>
                        <ul>
                            <li><strong>순수 함수</strong>: 같은 입력에 대해 항상 같은 출력, 부작용 없음</li>
                            <li><strong>불변성</strong>: 데이터를 변경하지 않고 새로운 데이터 생성</li>
                            <li><strong>고차 함수</strong>: 함수를 인자로 받거나 함수를 반환하는 함수</li>
                        </ul>
                        
                        <h3>순수 함수 예제</h3>
                        <pre><code class="language-javascript">
// 순수 함수 (Pure Function)
function add(a, b) {
  return a + b; // 항상 같은 입력에 같은 출력
}

// 비순수 함수 (Impure Function)
let counter = 0;
function incrementCounter() {
  counter++; // 외부 상태 변경 (부작용)
  return counter;
}
                        </code></pre>
                        
                        <h3>배열 고차 함수 활용</h3>
                        <pre><code class="language-javascript">
const numbers = [1, 2, 3, 4, 5];

// 함수형 스타일의 데이터 처리
const result = numbers
  .filter(n => n % 2 === 0)    // 짝수만 필터링
  .map(n => n * 2)             // 각 요소에 2를 곱함
  .reduce((sum, n) => sum + n, 0); // 합계 계산

console.log(result); // 12 (2*2 + 4*2 = 4 + 8 = 12)
                        </code></pre>
                        
                        <h3>커링 (Currying)</h3>
                        <p>여러 인자를 받는 함수를 하나의 인자만 받는 함수의 연속으로 변환하는 기법입니다.</p>
                        <pre><code class="language-javascript">
// 일반 함수
function multiply(a, b, c) {
  return a * b * c;
}

// 커링된 함수
function curriedMultiply(a) {
  return function(b) {
    return function(c) {
      return a * b * c;
    };
  };
}

// 화살표 함수로 더 간단하게
const curriedMultiplyArrow = a => b => c => a * b * c;

// 사용
const multiplyBy2 = curriedMultiplyArrow(2);
const multiplyBy2And3 = multiplyBy2(3);
console.log(multiplyBy2And3(4)); // 24
                        </code></pre>
                        
                        <h3>함수 조합 (Function Composition)</h3>
                        <pre><code class="language-javascript">
const compose = (f, g) => x => f(g(x));

const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;

const addOneThenMultiplyByTwo = compose(multiplyByTwo, addOne);
console.log(addOneThenMultiplyByTwo(3)); // 8 ((3 + 1) * 2)
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 18: 18-iteration 이터레이션 -->
                <section class="slide" id="iteration">
                    <div class="slide-content">
                        <h1>이터레이션</h1>
                        <h3>이터러블 (Iterable)과 이터레이터 (Iterator)</h3>
                        <ul>
                            <li><strong>이터러블</strong>: Symbol.iterator 메서드를 가진 객체</li>
                            <li><strong>이터레이터</strong>: next() 메서드를 가진 객체</li>
                        </ul>
                        
                        <h3>for...of 반복문</h3>
                        <p>이터러블 객체의 요소들을 순회합니다.</p>
                        <pre><code class="language-javascript">
// 배열 순회
const arr = [1, 2, 3];
for (const item of arr) {
  console.log(item); // 1, 2, 3
}

// 문자열 순회
const str = 'hello';
for (const char of str) {
  console.log(char); // 'h', 'e', 'l', 'l', 'o'
}

// Map 순회
const map = new Map([['a', 1], ['b', 2]]);
for (const [key, value] of map) {
  console.log(key, value); // 'a' 1, 'b' 2
}
                        </code></pre>
                        
                        <h3>제너레이터 (Generator)</h3>
                        <p>함수의 실행을 중간에 멈췄다가 재개할 수 있는 특별한 함수입니다.</p>
                        <pre><code class="language-javascript">
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

// for...of로 사용
for (const num of numberGenerator()) {
  console.log(num); // 1, 2, 3
}
                        </code></pre>
                        
                        <h3>무한 시퀀스 생성</h3>
                        <pre><code class="language-javascript">
function* infiniteNumbers() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const numbers = infiniteNumbers();
console.log(numbers.next().value); // 0
console.log(numbers.next().value); // 1
console.log(numbers.next().value); // 2

// 피보나치 수열 생성기
function* fibonacci() {
  let a = 0, b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacci();
for (let i = 0; i < 10; i++) {
  console.log(fib.next().value);
}
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 19: 19-class 클래스 -->
                <section class="slide" id="classes">
                    <div class="slide-content">
                        <h1>클래스</h1>
                        <h3>ES2015 클래스 문법</h3>
                        <p>프로토타입 기반 객체지향을 더 깔끔한 문법으로 표현할 수 있습니다.</p>
                        <pre><code class="language-javascript">
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`안녕하세요, ${this.name}입니다.`);
  }
  
  // getter
  get info() {
    return `${this.name} (${this.age}세)`;
  }
  
  // setter
  set age(value) {
    if (value < 0) {
      throw new Error('나이는 0 이상이어야 합니다.');
    }
    this._age = value;
  }
  
  // 정적 메서드
  static compare(person1, person2) {
    return person1.age - person2.age;
  }
}

const alice = new Person('Alice', 30);
alice.greet(); // "안녕하세요, Alice입니다."
console.log(alice.info); // "Alice (30세)"
                        </code></pre>
                        
                        <h3>상속</h3>
                        <pre><code class="language-javascript">
class Student extends Person {
  constructor(name, age, school) {
    super(name, age); // 부모 생성자 호출
    this.school = school;
  }
  
  study() {
    console.log(`${this.name}이(가) 공부하고 있습니다.`);
  }
  
  // 메서드 오버라이딩
  greet() {
    super.greet(); // 부모 메서드 호출
    console.log(`${this.school}에 다니고 있습니다.`);
  }
}

const bob = new Student('Bob', 20, '서울대학교');
bob.greet();
// "안녕하세요, Bob입니다."
// "서울대학교에 다니고 있습니다."
bob.study(); // "Bob이(가) 공부하고 있습니다."
                        </code></pre>
                        
                        <h3>프라이빗 필드 (ES2022)</h3>
                        <pre><code class="language-javascript">
class BankAccount {
  #balance = 0; // 프라이빗 변수
  
  constructor(initialBalance) {
    this.#balance = initialBalance;
  }
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount(1000);
account.deposit(500);
console.log(account.getBalance()); // 1500
// console.log(account.#balance); // SyntaxError: 접근 불가
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 20: 20-data-structures 자료구조 -->
                <section class="slide" id="data-structures">
                    <div class="slide-content">
                        <h1>자료구조</h1>
                        <h3>Map</h3>
                        <p>키-값 쌍을 저장하는 컬렉션으로, 모든 타입의 값을 키로 사용할 수 있습니다.</p>
                        <pre><code class="language-javascript">
const map = new Map();

// 설정
map.set('name', 'Alice');
map.set(1, 'number key');
map.set(true, 'boolean key');

// 조회
console.log(map.get('name')); // 'Alice'
console.log(map.has('name')); // true
console.log(map.size); // 3

// 순회
for (const [key, value] of map) {
  console.log(key, value);
}

// 객체와의 차이점
const obj = {}; // 키는 문자열만 가능
const map2 = new Map(); // 모든 타입의 키 가능
                        </code></pre>
                        
                        <h3>Set</h3>
                        <p>중복되지 않는 값들의 컬렉션입니다.</p>
                        <pre><code class="language-javascript">
const set = new Set();

// 추가
set.add(1);
set.add(2);
set.add(2); // 중복은 무시됨

console.log(set.size); // 2
console.log(set.has(1)); // true

// 배열에서 중복 제거
const numbers = [1, 2, 2, 3, 3, 4];
const uniqueNumbers = [...new Set(numbers)];
console.log(uniqueNumbers); // [1, 2, 3, 4]

// 순회
for (const value of set) {
  console.log(value);
}
                        </code></pre>
                        
                        <h3>WeakMap과 WeakSet</h3>
                        <p>약한 참조를 사용하는 컬렉션으로, 키나 값이 가비지 컬렉션될 수 있습니다.</p>
                        <pre><code class="language-javascript">
// WeakMap: 객체만을 키로 사용 가능
const weakMap = new WeakMap();
let obj = { name: 'Alice' };

weakMap.set(obj, 'some value');
console.log(weakMap.get(obj)); // 'some value'

obj = null; // 객체 참조 제거 시 WeakMap에서도 자동으로 제거됨

// WeakSet: 객체만을 값으로 저장 가능
const weakSet = new WeakSet();
let obj1 = { id: 1 };
let obj2 = { id: 2 };

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 21: 21-async 비동기 프로그래밍 -->
                <section class="slide" id="async">
                    <div class="slide-content">
                        <h1>비동기 프로그래밍</h1>
                        <h3>콜백 함수</h3>
                        <p>비동기 작업이 완료되었을 때 호출되는 함수입니다.</p>
                        <pre><code class="language-javascript">
// 콜백 함수의 문제점: 콜백 지옥
setTimeout(() => {
  console.log('1초 후');
  setTimeout(() => {
    console.log('2초 후');
    setTimeout(() => {
      console.log('3초 후');
    }, 1000);
  }, 1000);
}, 1000);
                        </code></pre>
                        
                        <h3>Promise</h3>
                        <p>비동기 작업의 결과를 나타내는 객체입니다.</p>
                        <pre><code class="language-javascript">
// Promise 생성
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = Math.random() > 0.5;
      if (success) {
        resolve('데이터를 성공적으로 가져왔습니다!');
      } else {
        reject(new Error('데이터 가져오기 실패'));
      }
    }, 1000);
  });
};

// Promise 사용
fetchData()
  .then(data => {
    console.log(data);
    return fetchData(); // 체이닝
  })
  .then(data => {
    console.log('두 번째:', data);
  })
  .catch(error => {
    console.error('에러:', error.message);
  });
                        </code></pre>
                        
                        <h3>async/await</h3>
                        <p>Promise를 더 읽기 쉬운 형태로 작성할 수 있게 해주는 문법입니다.</p>
                        <pre><code class="language-javascript">
async function getData() {
  try {
    const data1 = await fetchData();
    console.log('첫 번째:', data1);
    
    const data2 = await fetchData();
    console.log('두 번째:', data2);
    
    return '모든 데이터 처리 완료';
  } catch (error) {
    console.error('에러 발생:', error.message);
  }
}

// 사용
getData().then(result => {
  console.log(result);
});
                        </code></pre>
                        
                        <h3>Promise 유틸리티</h3>
                        <pre><code class="language-javascript">
// Promise.all: 모든 Promise가 완료될 때까지 대기
Promise.all([fetchData(), fetchData(), fetchData()])
  .then(results => {
    console.log('모든 결과:', results);
  });

// Promise.race: 가장 먼저 완료되는 Promise의 결과 반환
Promise.race([fetchData(), fetchData()])
  .then(result => {
    console.log('가장 빠른 결과:', result);
  });

// Promise.allSettled: 모든 Promise의 결과 (성공/실패 무관)
Promise.allSettled([fetchData(), fetchData()])
  .then(results => {
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        console.log(`${index}: 성공 -`, result.value);
      } else {
        console.log(`${index}: 실패 -`, result.reason);
      }
    });
  });
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 22: 22-exception 예외 처리 -->
                <section class="slide" id="exception">
                    <div class="slide-content">
                        <h1>예외 처리</h1>
                        <h3>try...catch...finally</h3>
                        <p>JavaScript에서 에러를 처리하는 핵심 메커니즘입니다.</p>
                        <pre><code class="language-javascript">
function parseJSON(jsonString) {
  try {
    const data = JSON.parse(jsonString);
    console.log('파싱 성공:', data);
    return data;
  } catch (error) {
    console.error('JSON 파싱 오류:', error.message);
    return null;
  } finally {
    console.log('JSON 파싱 시도 완료');
  }
}

// 사용 예제
parseJSON('{"name": "Alice"}'); // 성공
parseJSON('invalid json'); // 실패
                        </code></pre>
                        
                        <h3>사용자 정의 에러</h3>
                        <p>의도적으로 에러를 발생시키거나 커스텀 에러 클래스를 만들 수 있습니다.</p>
                        <pre><code class="language-javascript">
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

function validateAge(age) {
  if (typeof age !== 'number') {
    throw new ValidationError('나이는 숫자여야 합니다', 'age');
  }
  if (age < 0 || age > 150) {
    throw new ValidationError('나이는 0-150 사이여야 합니다', 'age');
  }
  return true;
}

try {
  validateAge(-5);
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(`유효성 검증 실패 (${error.field}): ${error.message}`);
  }
}
                        </code></pre>
                        
                        <h3>Promise 에러 처리</h3>
                        <pre><code class="language-javascript">
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const userData = await response.json();
    return userData;
  } catch (error) {
    console.error('사용자 데이터 가져오기 실패:', error.message);
    throw error; // 에러를 다시 던져서 호출자가 처리하도록
  }
}
                        </code></pre>
                        
                        <h3>전역 에러 처리</h3>
                        <pre><code class="language-javascript">
// 처리되지 않은 에러 처리
window.addEventListener('error', (event) => {
  console.error('전역 에러:', event.error);
});

// 처리되지 않은 Promise 거부 처리
window.addEventListener('unhandledrejection', (event) => {
  console.error('처리되지 않은 Promise 거부:', event.reason);
  event.preventDefault(); // 브라우저 기본 에러 처리 방지
});
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 23: 23-module 모듈 시스템 -->
                <section class="slide" id="module-system">
                    <div class="slide-content">
                        <h1>모듈 시스템 (ES2015)</h1>
                        <p>코드를 여러 파일로 분리하여 재사용성과 유지보수성을 높이는 시스템입니다.</p>
                        
                        <h3>export (내보내기)</h3>
                        <p>다른 파일에서 사용할 변수, 함수, 클래스를 지정합니다.</p>
                        <pre><code class="language-javascript">
// math.js

// 이름 지정 내보내기 (Named Export)
export const PI = 3.14;
export function add(a, b) {
  return a + b;
}

// 기본 내보내기 (Default Export, 파일당 하나만 가능)
export default class Calculator {
  // ...
}
                        </code></pre>

                        <h3>import (가져오기)</h3>
                        <p>다른 모듈에서 내보낸 기능들을 현재 파일로 가져옵니다.</p>
                        <pre><code class="language-javascript">
// main.js

// 이름 지정 가져오기 (중괄호 사용)
import { PI, add } from './math.js';

// 기본 가져오기 (원하는 이름으로)
import MyCalculator from './math.js';

// 전체 가져오기
import * as math from './math.js';
console.log(math.PI);
                        </code></pre>

                        <h3>모듈의 특징</h3>
                        <ul>
                            <li><strong>모듈 스코프:</strong> 모듈 내 최상위 변수는 전역 변수가 아닙니다.</li>
                            <li><strong>엄격 모드(Strict Mode):</strong> 자동으로 활성화됩니다.</li>
                            <li><strong>단 한 번만 실행:</strong> 같은 모듈을 여러 번 <code>import</code>해도 코드는 한 번만 실행됩니다.</li>
                        </ul>
                    </div>
                </section>

                <!-- Slide 24: 24-misc 기타 -->
                <section class="slide" id="misc">
                    <div class="slide-content">
                        <h1>기타 유용한 기능들</h1>
                        <h3>구조 분해 할당 (Destructuring)</h3>
                        <pre><code class="language-javascript">
// 배열 구조 분해
const [a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3

// 객체 구조 분해
const { name, age } = { name: 'Alice', age: 30, city: 'Seoul' };
console.log(name, age); // 'Alice' 30

// 함수 매개변수에서 구조 분해
function greet({ name, age }) {
  console.log(`안녕하세요, ${name}님! ${age}세이시군요.`);
}

greet({ name: 'Bob', age: 25 });
                        </code></pre>
                        
                        <h3>스프레드 연산자 (...)</h3>
                        <pre><code class="language-javascript">
// 배열 스프레드
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// 객체 스프레드
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// 함수 호출에서 스프레드
const numbers = [1, 2, 3];
console.log(Math.max(...numbers)); // 3
                        </code></pre>
                        
                        <h3>정규 표현식 (Regular Expression)</h3>
                        <pre><code class="language-javascript">
// 정규식 생성
const regex1 = /hello/i; // 리터럴 방식
const regex2 = new RegExp('hello', 'i'); // 생성자 방식

// 문자열 메서드와 함께 사용
const text = 'Hello, World!';
console.log(text.match(/[A-Z]/g)); // ['H', 'W'] (대문자 찾기)
console.log(text.replace(/Hello/, 'Hi')); // 'Hi, World!'

// 이메일 유효성 검사
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
console.log(emailRegex.test('user@example.com')); // true
                        </code></pre>
                        
                        <h3>JSON 처리</h3>
                        <pre><code class="language-javascript">
// 객체를 JSON 문자열로 변환
const obj = { name: 'Alice', age: 30 };
const jsonString = JSON.stringify(obj);
console.log(jsonString); // '{"name":"Alice","age":30}'

// JSON 문자열을 객체로 변환
const parsed = JSON.parse(jsonString);
console.log(parsed); // { name: 'Alice', age: 30 }

// 깊은 복사에 활용 (단, 함수, undefined, Symbol은 제외됨)
const deepCopy = JSON.parse(JSON.stringify(obj));
                        </code></pre>
                    </div>
                </section>

                <!-- Slide 25: Final -->
                <section class="slide title-slide" id="final">
                    <div class="slide-content">
                        <h1>학습을 마치며</h1>
                        <h2>꾸준함이 최고의 실력입니다.</h2>
                        <p style="margin-top: 50px;">지금까지 JavaScript의 핵심 개념들을 살펴보았습니다.<br>이제 실제 프로젝트에 적용하며 깊이를 더해보세요!</p>
                    </div>
                </section>
                
            </div>
            <div id="progress-bar">
                <div id="progress-indicator"></div>
            </div>
        </main>
    </div>

    <div id="controls">
        <button id="prev-btn">이전</button>
        <button id="next-btn">다음</button>
    </div>

    <script src="script.js"></script>
</body>
</html>