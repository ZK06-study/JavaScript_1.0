# 23. ëª¨ë“ˆ ì‹œìŠ¤í…œ - í€´ì¦ˆ

## ê°ê´€ì‹ ë¬¸ì œ

### 1. ğŸŸ¢ ES2015 ëª¨ë“ˆì—ì„œ ê¸°ë³¸ ë‚´ë³´ë‚´ê¸°ë¥¼ í•˜ëŠ” í‚¤ì›Œë“œëŠ”?
a) module.exports
b) export default
c) exports
d) default export

### 2. ğŸŸ¡ ë‹¤ìŒ ì¤‘ ì˜¬ë°”ë¥¸ import êµ¬ë¬¸ì€?
a) `import * from './module.js'`
b) `import { func } from './module.js'`
c) `import './module.js' from func`
d) `from './module.js' import func`

### 3. ğŸŸ  ëª¨ë“ˆì˜ íŠ¹ì§•ìœ¼ë¡œ í‹€ë¦° ê²ƒì€?
a) ìë™ìœ¼ë¡œ ì—„ê²© ëª¨ë“œê°€ ì ìš©ëœë‹¤
b) ìµœìƒìœ„ ë³€ìˆ˜ê°€ ì „ì—­ ìŠ¤ì½”í”„ì— ì¶”ê°€ëœë‹¤
c) í•œ ë²ˆë§Œ ì‹¤í–‰ëœë‹¤
d) ê³ ìœ í•œ ìŠ¤ì½”í”„ë¥¼ ê°€ì§„ë‹¤

### 4. ğŸŸ¡ ë™ì  importì˜ ë°˜í™˜ íƒ€ì…ì€?
a) ëª¨ë“ˆ ê°ì²´
b) Promise
c) undefined
d) Function

### 5. ğŸŸ  `import.meta`ì˜ ì£¼ìš” ìš©ë„ëŠ”?
a) ëª¨ë“ˆì„ ë™ì ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
b) ëª¨ë“ˆì— ëŒ€í•œ ë©”íƒ€ë°ì´í„° ì œê³µ
c) ëª¨ë“ˆì„ ë‚´ë³´ë‚´ê¸°
d) ëª¨ë“ˆì„ ì‚­ì œí•˜ê¸°

### 6. ğŸŸ¡ CommonJSì™€ ES ëª¨ë“ˆì˜ ì°¨ì´ì ìœ¼ë¡œ ì˜¬ë°”ë¥¸ ê²ƒì€?
a) CommonJSëŠ” ì •ì  ë¶„ì„ì´ ê°€ëŠ¥í•˜ë‹¤
b) ES ëª¨ë“ˆì€ ëŸ°íƒ€ì„ì— ì˜ì¡´ì„±ì„ ê²°ì •í•œë‹¤
c) ES ëª¨ë“ˆì€ ì •ì  ë¶„ì„ì´ ê°€ëŠ¥í•˜ë‹¤
d) ë‘˜ ë‹¤ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ì‘ë™í•œë‹¤

## ë‹¨ë‹µí˜• ë¬¸ì œ

### 7. ğŸŸ¢ ëª¨ë“  ë‚´ë³´ë‚´ê¸°ë¥¼ ê°€ì ¸ì˜¬ ë•Œ ì‚¬ìš©í•˜ëŠ” êµ¬ë¬¸ì˜ ì™€ì¼ë“œì¹´ë“œëŠ”?

### 8. ğŸŸ¡ ëª¨ë“ˆì„ ê°€ì ¸ì˜¬ ë•Œ ë³„ì¹­ì„ ì§€ì •í•˜ëŠ” í‚¤ì›Œë“œëŠ”?

### 9. ğŸŸ  Node.jsì—ì„œ ES ëª¨ë“ˆì„ ì‚¬ìš©í•˜ê¸° ìœ„í•œ package.json ì„¤ì •ì€?

### 10. ğŸŸ¢ side effectë§Œì„ ìœ„í•´ ëª¨ë“ˆì„ ê°€ì ¸ì˜¬ ë•Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì€?

## ì„œìˆ í˜• ë¬¸ì œ

### 11. ğŸŸ¡ ES ëª¨ë“ˆê³¼ CommonJSì˜ ì°¨ì´ì ì„ ë¹„êµí•˜ì—¬ ì„¤ëª…í•˜ì‹œì˜¤.

### 12. ğŸŸ  Tree Shakingì˜ ê°œë…ê³¼ ëª¨ë“ˆ ì‹œìŠ¤í…œì—ì„œì˜ ì¤‘ìš”ì„±ì„ ì„¤ëª…í•˜ì‹œì˜¤.

### 13. ğŸŸ¡ ëª¨ë“ˆì˜ ìˆœí™˜ ì°¸ì¡° ë¬¸ì œì™€ í•´ê²° ë°©ë²•ì„ ì„¤ëª…í•˜ì‹œì˜¤.

## ì½”ë”© ë¬¸ì œ

### 14. ğŸŸ¢ ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ëª¨ë“ˆì„ ì‘ì„±í•˜ì‹œì˜¤.
```javascript
// math.js - ìˆ˜í•™ ìœ í‹¸ë¦¬í‹° ëª¨ë“ˆ
// 1. add, subtract, multiply í•¨ìˆ˜ ë‚´ë³´ë‚´ê¸°
// 2. PI ìƒìˆ˜ ë‚´ë³´ë‚´ê¸°  
// 3. Calculator í´ë˜ìŠ¤ë¥¼ ê¸°ë³¸ ë‚´ë³´ë‚´ê¸°

// main.js - ëª¨ë“ˆ ì‚¬ìš©
// ìœ„ í•¨ìˆ˜ë“¤ê³¼ í´ë˜ìŠ¤ë¥¼ ê°€ì ¸ì™€ì„œ ì‚¬ìš©
```

### 15. ğŸŸ¡ ë™ì  importë¥¼ í™œìš©í•œ ì§€ì—° ë¡œë”© ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ì‹œì˜¤.
```javascript
// ì¡°ê±´ì— ë”°ë¼ ëª¨ë“ˆì„ ë™ì ìœ¼ë¡œ ë¡œë“œ
// ë¡œë”© ìƒíƒœ í‘œì‹œ í¬í•¨
// ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨
```

### 16. ğŸŸ  ëª¨ë“ˆ ë²ˆë“¤ëŸ¬ ì—†ì´ ë¸Œë¼ìš°ì €ì—ì„œ ES ëª¨ë“ˆì„ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
```javascript
// HTMLì—ì„œ ì§ì ‘ ëª¨ë“ˆ ë¡œë“œ
// import map ì‚¬ìš©
// ë‹¤ì–‘í•œ ëª¨ë“ˆ íŒ¨í„´ êµ¬í˜„
```

### 17. ğŸŸ¡ ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ì‹œì˜¤.
```javascript
// ëª¨ë“ˆ ë“±ë¡ ë° ì˜ì¡´ì„± ê´€ë¦¬
// ë²„ì „ ê´€ë¦¬ ê¸°ëŠ¥
// ì§€ì—° ë¡œë”© ì§€ì›
```

## ì‘ìš© ë¬¸ì œ

### 18. ğŸŸ  ë‹¤ìŒ ì½”ë“œì˜ ì‹¤í–‰ ê²°ê³¼ë¥¼ ì˜ˆìƒí•˜ê³  ì„¤ëª…í•˜ì‹œì˜¤.
```javascript
// a.js
import { valueFromB } from './b.js';
export const valueFromA = 'A';
console.log('A:', valueFromB);

// b.js  
import { valueFromA } from './a.js';
export const valueFromB = 'B';
console.log('B:', valueFromA);

// main.js
import './a.js';
```

### 19. ğŸŸ  ëª¨ë“ˆ ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ì‹œì˜¤.
```javascript
// í”ŒëŸ¬ê·¸ì¸ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
// í”ŒëŸ¬ê·¸ì¸ ë™ì  ë¡œë”©
// í”ŒëŸ¬ê·¸ì¸ ê°„ í†µì‹ 
// í”ŒëŸ¬ê·¸ì¸ ìƒëª…ì£¼ê¸° ê´€ë¦¬
```

### 20. ğŸŸ  ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œë¥¼ ìœ„í•œ ëª¨ë“ˆ í˜ë”ë ˆì´ì…˜ì„ êµ¬í˜„í•˜ì‹œì˜¤.
```javascript
// ì›ê²© ëª¨ë“ˆ ë¡œë”©
// ëª¨ë“ˆ ê°„ ìƒíƒœ ê³µìœ 
// ë²„ì „ í˜¸í™˜ì„± ê´€ë¦¬
```

---

## ì •ë‹µ

### ê°ê´€ì‹ ì •ë‹µ
1. b) export default
2. b) `import { func } from './module.js'`
3. b) ìµœìƒìœ„ ë³€ìˆ˜ê°€ ì „ì—­ ìŠ¤ì½”í”„ì— ì¶”ê°€ëœë‹¤ (ëª¨ë“ˆ ìŠ¤ì½”í”„ì—ë§Œ ì¶”ê°€ë¨)
4. b) Promise
5. b) ëª¨ë“ˆì— ëŒ€í•œ ë©”íƒ€ë°ì´í„° ì œê³µ
6. c) ES ëª¨ë“ˆì€ ì •ì  ë¶„ì„ì´ ê°€ëŠ¥í•˜ë‹¤

### ë‹¨ë‹µí˜• ì •ë‹µ
7. `*` (ì• ìŠ¤í„°ë¦¬ìŠ¤í¬)
8. `as`
9. `"type": "module"`
10. `import './module.js'`

### ì„œìˆ í˜• ì •ë‹µ
11. **ES ëª¨ë“ˆ vs CommonJS:**

| íŠ¹ì§• | ES ëª¨ë“ˆ | CommonJS |
|------|---------|----------|
| ë¬¸ë²• | import/export | require/module.exports |
| ë¡œë”© ì‹œì  | ì»´íŒŒì¼ íƒ€ì„ | ëŸ°íƒ€ì„ |
| ì •ì  ë¶„ì„ | ê°€ëŠ¥ | ë¶ˆê°€ëŠ¥ |
| Tree Shaking | ì§€ì› | ì œí•œì  |
| ë¸Œë¼ìš°ì € ì§€ì› | ë„¤ì´í‹°ë¸Œ | ë¶ˆê°€ëŠ¥ |
| ìˆœí™˜ ì°¸ì¡° | ë” ì•ˆì „í•¨ | ë¬¸ì œ ë°œìƒ ê°€ëŠ¥ |

12. **Tree Shaking:**
- ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì½”ë“œë¥¼ ì œê±°í•˜ì—¬ ë²ˆë“¤ í¬ê¸° ìµœì í™”
- ES ëª¨ë“ˆì˜ ì •ì  ë¶„ì„ ë•ë¶„ì— ê°€ëŠ¥
- ë²ˆë“¤ëŸ¬ê°€ import/exportë¥¼ ë¶„ì„í•˜ì—¬ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” exports ì œê±°

13. **ìˆœí™˜ ì°¸ì¡°:**
- ë‘ ëª¨ë“ˆì´ ì„œë¡œë¥¼ ì°¸ì¡°í•˜ëŠ” ìƒí™©
- **í•´ê²°ë²•**: ì˜ì¡´ì„± ì—­ì „, ê³µí†µ ëª¨ë“ˆ ë¶„ë¦¬, ì§€ì—° ë¡œë”©

### ì½”ë”© ì •ë‹µ
14.
```javascript
// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export function multiply(a, b) {
  return a * b;
}

export const PI = 3.14159;

export default class Calculator {
  constructor() {
    this.history = [];
  }
  
  add(a, b) {
    const result = add(a, b);
    this.history.push(`${a} + ${b} = ${result}`);
    return result;
  }
  
  subtract(a, b) {
    const result = subtract(a, b);
    this.history.push(`${a} - ${b} = ${result}`);
    return result;
  }
  
  multiply(a, b) {
    const result = multiply(a, b);
    this.history.push(`${a} * ${b} = ${result}`);
    return result;
  }
  
  getHistory() {
    return [...this.history];
  }
  
  clear() {
    this.history = [];
  }
}

// main.js
import Calculator, { add, subtract, multiply, PI } from './math.js';

// ê°œë³„ í•¨ìˆ˜ ì‚¬ìš©
console.log('ë§ì…ˆ:', add(5, 3)); // 8
console.log('ëº„ì…ˆ:', subtract(10, 4)); // 6
console.log('ê³±ì…ˆ:', multiply(3, 7)); // 21
console.log('ì›ì£¼ìœ¨:', PI); // 3.14159

// í´ë˜ìŠ¤ ì‚¬ìš©
const calc = new Calculator();
calc.add(10, 20);
calc.multiply(5, 4);
console.log('ê³„ì‚° ê¸°ë¡:', calc.getHistory());

// ë³„ì¹­ ì‚¬ìš©
import { add as plus, multiply as times } from './math.js';
console.log('ë³„ì¹­ ì‚¬ìš©:', plus(1, 2), times(3, 4));

// ì „ì²´ ê°€ì ¸ì˜¤ê¸°
import * as MathUtils from './math.js';
console.log('ì „ì²´ ê°€ì ¸ì˜¤ê¸°:', MathUtils.add(1, 1));
```

15.
```javascript
// ë™ì  importë¥¼ í™œìš©í•œ ì§€ì—° ë¡œë”© ì‹œìŠ¤í…œ
class ModuleLoader {
  constructor() {
    this.cache = new Map();
    this.loading = new Map();
    this.loadingIndicator = null;
  }
  
  // ë¡œë”© ìƒíƒœ í‘œì‹œ
  showLoading(message = 'Loading...') {
    if (this.loadingIndicator) return;
    
    this.loadingIndicator = document.createElement('div');
    this.loadingIndicator.className = 'loading-indicator';
    this.loadingIndicator.textContent = message;
    this.loadingIndicator.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 20px;
      border-radius: 5px;
      z-index: 10000;
    `;
    document.body.appendChild(this.loadingIndicator);
  }
  
  hideLoading() {
    if (this.loadingIndicator) {
      document.body.removeChild(this.loadingIndicator);
      this.loadingIndicator = null;
    }
  }
  
  // ëª¨ë“ˆ ë™ì  ë¡œë”©
  async loadModule(modulePath, options = {}) {
    const {
      useCache = true,
      showLoading = true,
      timeout = 10000
    } = options;
    
    // ìºì‹œì—ì„œ í™•ì¸
    if (useCache && this.cache.has(modulePath)) {
      return this.cache.get(modulePath);
    }
    
    // ì´ë¯¸ ë¡œë”© ì¤‘ì¸ì§€ í™•ì¸
    if (this.loading.has(modulePath)) {
      return this.loading.get(modulePath);
    }
    
    // ë¡œë”© ì‹œì‘
    if (showLoading) {
      this.showLoading(`Loading ${modulePath}...`);
    }
    
    const loadPromise = this.performLoad(modulePath, timeout);
    this.loading.set(modulePath, loadPromise);
    
    try {
      const module = await loadPromise;
      
      // ìºì‹œì— ì €ì¥
      if (useCache) {
        this.cache.set(modulePath, module);
      }
      
      return module;
      
    } finally {
      this.loading.delete(modulePath);
      if (showLoading) {
        this.hideLoading();
      }
    }
  }
  
  // ì‹¤ì œ ë¡œë”© ìˆ˜í–‰
  async performLoad(modulePath, timeout) {
    return new Promise(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Module loading timeout: ${modulePath}`));
      }, timeout);
      
      try {
        const module = await import(modulePath);
        clearTimeout(timeoutId);
        resolve(module);
      } catch (error) {
        clearTimeout(timeoutId);
        reject(new Error(`Failed to load module ${modulePath}: ${error.message}`));
      }
    });
  }
  
  // ì¡°ê±´ë¶€ ë¡œë”©
  async loadConditionally(condition, modulePath, fallbackPath = null) {
    if (condition) {
      return this.loadModule(modulePath);
    } else if (fallbackPath) {
      return this.loadModule(fallbackPath);
    }
    return null;
  }
  
  // ë°°ì¹˜ ë¡œë”©
  async loadBatch(modulePaths, options = {}) {
    const { parallel = true } = options;
    
    if (parallel) {
      return Promise.allSettled(
        modulePaths.map(path => this.loadModule(path, options))
      );
    } else {
      const results = [];
      for (const path of modulePaths) {
        try {
          const module = await this.loadModule(path, options);
          results.push({ status: 'fulfilled', value: module });
        } catch (error) {
          results.push({ status: 'rejected', reason: error });
        }
      }
      return results;
    }
  }
  
  // ìºì‹œ ê´€ë¦¬
  clearCache(modulePath = null) {
    if (modulePath) {
      this.cache.delete(modulePath);
    } else {
      this.cache.clear();
    }
  }
  
  getCacheStats() {
    return {
      cached: this.cache.size,
      loading: this.loading.size,
      paths: [...this.cache.keys()]
    };
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const loader = new ModuleLoader();

// ê¸°ë³¸ ì‚¬ìš©ë²•
document.getElementById('load-chart').addEventListener('click', async () => {
  try {
    const chartModule = await loader.loadModule('./chart-module.js');
    const chart = new chartModule.Chart('#chart-container');
    chart.render();
  } catch (error) {
    console.error('ì°¨íŠ¸ ëª¨ë“ˆ ë¡œë”© ì‹¤íŒ¨:', error);
  }
});

// ì¡°ê±´ë¶€ ë¡œë”©
const userRole = 'admin';
const adminModule = await loader.loadConditionally(
  userRole === 'admin',
  './admin-module.js',
  './user-module.js'
);

// ë°°ì¹˜ ë¡œë”©
const modules = await loader.loadBatch([
  './utils.js',
  './api.js',
  './ui-components.js'
], { parallel: true });

console.log('ë¡œë” í†µê³„:', loader.getCacheStats());
```

16.
```javascript
// index.html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES ëª¨ë“ˆ ì˜ˆì œ</title>
    
    <!-- Import Map ì„¤ì • -->
    <script type="importmap">
    {
      "imports": {
        "lodash": "https://cdn.skypack.dev/lodash",
        "dayjs": "https://cdn.skypack.dev/dayjs",
        "utils/": "./modules/utils/",
        "components/": "./modules/components/"
      }
    }
    </script>
</head>
<body>
    <div id="app"></div>
    
    <!-- ES ëª¨ë“ˆë¡œ ë©”ì¸ ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ -->
    <script type="module" src="./main.js"></script>
</body>
</html>

// modules/utils/math.js
export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

export default class MathUtils {
  static factorial(n) {
    if (n <= 1) return 1;
    return n * this.factorial(n - 1);
  }
  
  static isPrime(n) {
    if (n < 2) return false;
    for (let i = 2; i <= Math.sqrt(n); i++) {
      if (n % i === 0) return false;
    }
    return true;
  }
}

// modules/components/button.js
export class Button {
  constructor(text, onClick) {
    this.element = document.createElement('button');
    this.element.textContent = text;
    this.element.addEventListener('click', onClick);
  }
  
  render(container) {
    container.appendChild(this.element);
  }
  
  setDisabled(disabled) {
    this.element.disabled = disabled;
  }
}

// modules/api/client.js
export class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  async get(endpoint) {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  }
  
  async post(endpoint, data) {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  }
}

// main.js
// Import Mapì„ ì‚¬ìš©í•œ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê°€ì ¸ì˜¤ê¸°
import _ from 'lodash';
import dayjs from 'dayjs';

// ë¡œì»¬ ëª¨ë“ˆ ê°€ì ¸ì˜¤ê¸°
import MathUtils, { add, multiply } from 'utils/math.js';
import { Button } from 'components/button.js';
import { ApiClient } from './modules/api/client.js';

// ë™ì  import ì˜ˆì œ
async function loadUtilsModule() {
  const { default: UtilsClass } = await import('./modules/utils/string-utils.js');
  return new UtilsClass();
}

// ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
class App {
  constructor() {
    this.container = document.getElementById('app');
    this.api = new ApiClient('https://api.example.com');
    this.init();
  }
  
  async init() {
    // ìˆ˜í•™ ìœ í‹¸ë¦¬í‹° ì‚¬ìš©
    console.log('5 + 3 =', add(5, 3));
    console.log('4 * 6 =', multiply(4, 6));
    console.log('5! =', MathUtils.factorial(5));
    
    // ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
    const numbers = [1, 2, 3, 4, 5];
    console.log('Sum:', _.sum(numbers));
    console.log('Current time:', dayjs().format('YYYY-MM-DD HH:mm:ss'));
    
    // ë™ì  ëª¨ë“ˆ ë¡œë”©
    try {
      const stringUtils = await loadUtilsModule();
      console.log('String utils loaded:', stringUtils);
    } catch (error) {
      console.error('Failed to load string utils:', error);
    }
    
    // UI ì»´í¬ë„ŒíŠ¸ ìƒì„±
    this.createUI();
  }
  
  createUI() {
    const title = document.createElement('h1');
    title.textContent = 'ES ëª¨ë“ˆ ì˜ˆì œ';
    this.container.appendChild(title);
    
    const button = new Button('í´ë¦­í•˜ì„¸ìš”!', () => {
      alert('ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤!');
    });
    button.render(this.container);
    
    // API í˜¸ì¶œ ë²„íŠ¼
    const apiButton = new Button('API í˜¸ì¶œ', async () => {
      try {
        apiButton.setDisabled(true);
        const data = await this.api.get('/users/1');
        console.log('API ì‘ë‹µ:', data);
      } catch (error) {
        console.error('API í˜¸ì¶œ ì‹¤íŒ¨:', error);
      } finally {
        apiButton.setDisabled(false);
      }
    });
    apiButton.render(this.container);
  }
}

// ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
new App();

// modules/utils/string-utils.js (ë™ì  ë¡œë”©ìš©)
export default class StringUtils {
  static capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }
  
  static kebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }
  
  static truncate(str, maxLength) {
    if (str.length <= maxLength) return str;
    return str.slice(0, maxLength - 3) + '...';
  }
}
```

17.
```javascript
// ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì‹œìŠ¤í…œ
class ModuleRegistry {
  constructor() {
    this.modules = new Map();
    this.dependencies = new Map();
    this.versions = new Map();
    this.loadingPromises = new Map();
  }
  
  // ëª¨ë“ˆ ë“±ë¡
  register(name, version, factory, dependencies = []) {
    const moduleKey = `${name}@${version}`;
    
    if (this.modules.has(moduleKey)) {
      throw new Error(`Module ${moduleKey} is already registered`);
    }
    
    this.modules.set(moduleKey, {
      name,
      version,
      factory,
      dependencies,
      instance: null,
      loaded: false
    });
    
    // ë²„ì „ ê´€ë¦¬
    if (!this.versions.has(name)) {
      this.versions.set(name, []);
    }
    this.versions.get(name).push(version);
    this.versions.get(name).sort(this.compareVersions);
    
    // ì˜ì¡´ì„± ê¸°ë¡
    this.dependencies.set(moduleKey, dependencies);
  }
  
  // ëª¨ë“ˆ ë¡œë“œ
  async load(name, version = 'latest') {
    const resolvedVersion = this.resolveVersion(name, version);
    const moduleKey = `${name}@${resolvedVersion}`;
    
    // ì´ë¯¸ ë¡œë”© ì¤‘ì´ë©´ ê¸°ë‹¤ë¦¼
    if (this.loadingPromises.has(moduleKey)) {
      return this.loadingPromises.get(moduleKey);
    }
    
    // ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜
    const moduleInfo = this.modules.get(moduleKey);
    if (!moduleInfo) {
      throw new Error(`Module ${moduleKey} not found`);
    }
    
    if (moduleInfo.loaded) {
      return moduleInfo.instance;
    }
    
    // ë¡œë”© í”„ë¡œë¯¸ìŠ¤ ìƒì„±
    const loadingPromise = this.performLoad(moduleKey);
    this.loadingPromises.set(moduleKey, loadingPromise);
    
    try {
      const instance = await loadingPromise;
      return instance;
    } finally {
      this.loadingPromises.delete(moduleKey);
    }
  }
  
  // ì‹¤ì œ ë¡œë”© ìˆ˜í–‰
  async performLoad(moduleKey) {
    const moduleInfo = this.modules.get(moduleKey);
    
    // ì˜ì¡´ì„± ë¨¼ì € ë¡œë“œ
    const dependencies = {};
    for (const depName of moduleInfo.dependencies) {
      dependencies[depName] = await this.load(depName);
    }
    
    // ëª¨ë“ˆ íŒ©í† ë¦¬ ì‹¤í–‰
    try {
      moduleInfo.instance = await moduleInfo.factory(dependencies);
      moduleInfo.loaded = true;
      return moduleInfo.instance;
    } catch (error) {
      throw new Error(`Failed to load module ${moduleKey}: ${error.message}`);
    }
  }
  
  // ë²„ì „ í•´ê²°
  resolveVersion(name, requestedVersion) {
    const availableVersions = this.versions.get(name);
    if (!availableVersions || availableVersions.length === 0) {
      throw new Error(`No versions available for module ${name}`);
    }
    
    if (requestedVersion === 'latest') {
      return availableVersions[availableVersions.length - 1];
    }
    
    if (availableVersions.includes(requestedVersion)) {
      return requestedVersion;
    }
    
    // í˜¸í™˜ ë²„ì „ ì°¾ê¸° (semver ê°„ë‹¨ êµ¬í˜„)
    const compatible = availableVersions.filter(v => 
      this.isCompatible(requestedVersion, v)
    );
    
    if (compatible.length === 0) {
      throw new Error(`No compatible version found for ${name}@${requestedVersion}`);
    }
    
    return compatible[compatible.length - 1];
  }
  
  // ë²„ì „ ë¹„êµ
  compareVersions(a, b) {
    const aParts = a.split('.').map(Number);
    const bParts = b.split('.').map(Number);
    
    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
      const aPart = aParts[i] || 0;
      const bPart = bParts[i] || 0;
      
      if (aPart < bPart) return -1;
      if (aPart > bPart) return 1;
    }
    
    return 0;
  }
  
  // í˜¸í™˜ì„± í™•ì¸ (ê°„ë‹¨í•œ semver)
  isCompatible(requested, available) {
    const reqParts = requested.split('.').map(Number);
    const availParts = available.split('.').map(Number);
    
    // ë©”ì´ì € ë²„ì „ì´ ë‹¤ë¥´ë©´ í˜¸í™˜ ë¶ˆê°€
    if (reqParts[0] !== availParts[0]) return false;
    
    // ë§ˆì´ë„ˆ ë²„ì „ì´ ë” ë‚®ìœ¼ë©´ í˜¸í™˜ ë¶ˆê°€
    if (availParts[1] < reqParts[1]) return false;
    
    return true;
  }
  
  // ì˜ì¡´ì„± ê·¸ë˜í”„ ë¶„ì„
  getDependencyGraph(name, version = 'latest') {
    const resolvedVersion = this.resolveVersion(name, version);
    const moduleKey = `${name}@${resolvedVersion}`;
    const visited = new Set();
    const graph = {};
    
    const buildGraph = (key) => {
      if (visited.has(key)) return;
      visited.add(key);
      
      const moduleInfo = this.modules.get(key);
      if (!moduleInfo) return;
      
      graph[key] = moduleInfo.dependencies.map(depName => {
        const depVersion = this.resolveVersion(depName, 'latest');
        const depKey = `${depName}@${depVersion}`;
        buildGraph(depKey);
        return depKey;
      });
    };
    
    buildGraph(moduleKey);
    return graph;
  }
  
  // ìˆœí™˜ ì˜ì¡´ì„± ê²€ì‚¬
  hasCircularDependency(name, version = 'latest') {
    const graph = this.getDependencyGraph(name, version);
    const visiting = new Set();
    const visited = new Set();
    
    const hasCycle = (node) => {
      if (visiting.has(node)) return true;
      if (visited.has(node)) return false;
      
      visiting.add(node);
      
      for (const dependency of graph[node] || []) {
        if (hasCycle(dependency)) return true;
      }
      
      visiting.delete(node);
      visited.add(node);
      return false;
    };
    
    const startNode = `${name}@${this.resolveVersion(name, version)}`;
    return hasCycle(startNode);
  }
  
  // í†µê³„ ì •ë³´
  getStats() {
    return {
      totalModules: this.modules.size,
      loadedModules: Array.from(this.modules.values()).filter(m => m.loaded).length,
      loadingModules: this.loadingPromises.size,
      moduleNames: Array.from(this.versions.keys())
    };
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const registry = new ModuleRegistry();

// ìœ í‹¸ë¦¬í‹° ëª¨ë“ˆ ë“±ë¡
registry.register('utils', '1.0.0', async () => {
  return {
    formatDate: (date) => date.toISOString(),
    capitalize: (str) => str.charAt(0).toUpperCase() + str.slice(1)
  };
});

// HTTP í´ë¼ì´ì–¸íŠ¸ ëª¨ë“ˆ ë“±ë¡ (utilsì— ì˜ì¡´)
registry.register('http-client', '1.0.0', async (deps) => {
  const utils = deps.utils;
  
  return {
    async get(url) {
      console.log(`GET ${url} at ${utils.formatDate(new Date())}`);
      const response = await fetch(url);
      return response.json();
    },
    
    async post(url, data) {
      console.log(`POST ${url} at ${utils.formatDate(new Date())}`);
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      return response.json();
    }
  };
}, ['utils']);

// ì‚¬ìš©ì ì„œë¹„ìŠ¤ ëª¨ë“ˆ ë“±ë¡ (http-clientì— ì˜ì¡´)
registry.register('user-service', '1.0.0', async (deps) => {
  const httpClient = deps['http-client'];
  
  return {
    async getUser(id) {
      return httpClient.get(`/api/users/${id}`);
    },
    
    async createUser(userData) {
      return httpClient.post('/api/users', userData);
    }
  };
}, ['http-client']);

// ëª¨ë“ˆ ì‚¬ìš©
async function useModules() {
  try {
    // ì˜ì¡´ì„± ê·¸ë˜í”„ í™•ì¸
    console.log('ì˜ì¡´ì„± ê·¸ë˜í”„:', registry.getDependencyGraph('user-service'));
    console.log('ìˆœí™˜ ì˜ì¡´ì„±:', registry.hasCircularDependency('user-service'));
    
    // ëª¨ë“ˆ ë¡œë“œ ë° ì‚¬ìš©
    const userService = await registry.load('user-service');
    const userData = await userService.getUser(123);
    console.log('ì‚¬ìš©ì ë°ì´í„°:', userData);
    
    // í†µê³„ í™•ì¸
    console.log('ë ˆì§€ìŠ¤íŠ¸ë¦¬ í†µê³„:', registry.getStats());
    
  } catch (error) {
    console.error('ëª¨ë“ˆ ë¡œë”© ì‹¤íŒ¨:', error);
  }
}

useModules();
```

### ì‘ìš© ì •ë‹µ
18.
```javascript
// ì‹¤í–‰ ê²°ê³¼:
// B: undefined
// A: B

// ì„¤ëª…:
// 1. main.jsê°€ a.jsë¥¼ import
// 2. a.jsê°€ b.jsë¥¼ importí•˜ë ¤ í•˜ì§€ë§Œ, b.jsëŠ” ì•„ì§ í‰ê°€ë˜ì§€ ì•ŠìŒ
// 3. b.jsê°€ a.jsë¥¼ importí•˜ë ¤ í•˜ì§€ë§Œ, a.jsë„ ì•„ì§ ì™„ì „íˆ í‰ê°€ë˜ì§€ ì•ŠìŒ
// 4. b.jsì—ì„œ valueFromAëŠ” ì•„ì§ undefined (í˜¸ì´ìŠ¤íŒ…ë˜ì—ˆì§€ë§Œ ì´ˆê¸°í™” ì•ˆë¨)
// 5. b.js í‰ê°€ ì™„ë£Œ í›„ a.jsê°€ valueFromBì— ì ‘ê·¼ ê°€ëŠ¥

// ES ëª¨ë“ˆì€ ìˆœí™˜ ì°¸ì¡°ë¥¼ í—ˆìš©í•˜ì§€ë§Œ, ì´ˆê¸°í™” ìˆœì„œì— ì£¼ì˜í•´ì•¼ í•¨
```

19.
```javascript
// ëª¨ë“ˆ ê¸°ë°˜ í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ
class PluginSystem {
  constructor() {
    this.plugins = new Map();
    this.hooks = new Map();
    this.eventBus = new EventTarget();
  }
  
  // í”ŒëŸ¬ê·¸ì¸ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
  defineInterface(name, methods) {
    this.interfaces = this.interfaces || new Map();
    this.interfaces.set(name, methods);
  }
  
  // í”ŒëŸ¬ê·¸ì¸ ë“±ë¡
  async registerPlugin(name, pluginModule, config = {}) {
    try {
      // í”ŒëŸ¬ê·¸ì¸ ëª¨ë“ˆ ë¡œë“œ
      const plugin = typeof pluginModule === 'string' 
        ? await import(pluginModule)
        : pluginModule;
      
      // ì¸í„°í˜ì´ìŠ¤ ê²€ì¦
      if (plugin.interface && this.interfaces.has(plugin.interface)) {
        this.validateInterface(plugin, plugin.interface);
      }
      
      // í”ŒëŸ¬ê·¸ì¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
      const instance = new plugin.default(config);
      
      this.plugins.set(name, {
        instance,
        config,
        loaded: false,
        active: false,
        hooks: new Set(),
        dependencies: plugin.dependencies || []
      });
      
      // ìƒëª…ì£¼ê¸° ì´ë²¤íŠ¸ ë°œìƒ
      this.emit('plugin:registered', { name, plugin: instance });
      
      return instance;
      
    } catch (error) {
      this.emit('plugin:error', { name, error });
      throw new Error(`Failed to register plugin ${name}: ${error.message}`);
    }
  }
  
  // ì¸í„°í˜ì´ìŠ¤ ê²€ì¦
  validateInterface(plugin, interfaceName) {
    const requiredMethods = this.interfaces.get(interfaceName);
    const pluginClass = plugin.default;
    
    for (const method of requiredMethods) {
      if (typeof pluginClass.prototype[method] !== 'function') {
        throw new Error(`Plugin missing required method: ${method}`);
      }
    }
  }
  
  // í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ
  async loadPlugin(name) {
    const pluginInfo = this.plugins.get(name);
    if (!pluginInfo) {
      throw new Error(`Plugin ${name} not found`);
    }
    
    if (pluginInfo.loaded) return;
    
    // ì˜ì¡´ì„± ë¨¼ì € ë¡œë“œ
    for (const dependency of pluginInfo.dependencies) {
      await this.loadPlugin(dependency);
    }
    
    try {
      // í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™”
      if (typeof pluginInfo.instance.initialize === 'function') {
        await pluginInfo.instance.initialize(this);
      }
      
      pluginInfo.loaded = true;
      this.emit('plugin:loaded', { name, plugin: pluginInfo.instance });
      
    } catch (error) {
      this.emit('plugin:error', { name, error });
      throw error;
    }
  }
  
  // í”ŒëŸ¬ê·¸ì¸ í™œì„±í™”
  async activatePlugin(name) {
    const pluginInfo = this.plugins.get(name);
    if (!pluginInfo) {
      throw new Error(`Plugin ${name} not found`);
    }
    
    if (!pluginInfo.loaded) {
      await this.loadPlugin(name);
    }
    
    if (pluginInfo.active) return;
    
    try {
      if (typeof pluginInfo.instance.activate === 'function') {
        await pluginInfo.instance.activate();
      }
      
      pluginInfo.active = true;
      this.emit('plugin:activated', { name, plugin: pluginInfo.instance });
      
    } catch (error) {
      this.emit('plugin:error', { name, error });
      throw error;
    }
  }
  
  // í”ŒëŸ¬ê·¸ì¸ ë¹„í™œì„±í™”
  async deactivatePlugin(name) {
    const pluginInfo = this.plugins.get(name);
    if (!pluginInfo || !pluginInfo.active) return;
    
    try {
      if (typeof pluginInfo.instance.deactivate === 'function') {
        await pluginInfo.instance.deactivate();
      }
      
      // ë“±ë¡ëœ í›… ì •ë¦¬
      for (const hookName of pluginInfo.hooks) {
        this.removeHook(hookName, pluginInfo.instance);
      }
      
      pluginInfo.active = false;
      this.emit('plugin:deactivated', { name, plugin: pluginInfo.instance });
      
    } catch (error) {
      this.emit('plugin:error', { name, error });
      throw error;
    }
  }
  
  // í›… ì‹œìŠ¤í…œ
  addHook(name, callback, priority = 10) {
    if (!this.hooks.has(name)) {
      this.hooks.set(name, []);
    }
    
    this.hooks.get(name).push({ callback, priority });
    this.hooks.get(name).sort((a, b) => a.priority - b.priority);
  }
  
  removeHook(name, callback) {
    if (!this.hooks.has(name)) return;
    
    const hooks = this.hooks.get(name);
    const index = hooks.findIndex(hook => hook.callback === callback);
    if (index !== -1) {
      hooks.splice(index, 1);
    }
  }
  
  async executeHook(name, data = {}) {
    if (!this.hooks.has(name)) return data;
    
    let result = data;
    for (const hook of this.hooks.get(name)) {
      try {
        const hookResult = await hook.callback(result);
        if (hookResult !== undefined) {
          result = hookResult;
        }
      } catch (error) {
        this.emit('hook:error', { name, error });
      }
    }
    
    return result;
  }
  
  // ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
  emit(eventName, data) {
    this.eventBus.dispatchEvent(new CustomEvent(eventName, { detail: data }));
  }
  
  on(eventName, callback) {
    this.eventBus.addEventListener(eventName, callback);
  }
  
  off(eventName, callback) {
    this.eventBus.removeEventListener(eventName, callback);
  }
  
  // í”ŒëŸ¬ê·¸ì¸ ê°„ í†µì‹ 
  sendMessage(fromPlugin, toPlugin, message) {
    const targetPlugin = this.plugins.get(toPlugin);
    if (targetPlugin && targetPlugin.active) {
      if (typeof targetPlugin.instance.receiveMessage === 'function') {
        targetPlugin.instance.receiveMessage(fromPlugin, message);
      }
    }
  }
  
  // í†µê³„ ë° ê´€ë¦¬
  getPluginInfo(name) {
    return this.plugins.get(name);
  }
  
  listPlugins() {
    return Array.from(this.plugins.keys());
  }
  
  getActivePlugins() {
    return Array.from(this.plugins.entries())
      .filter(([name, info]) => info.active)
      .map(([name, info]) => name);
  }
}

// í”ŒëŸ¬ê·¸ì¸ ì˜ˆì œ
// plugins/logger.js
export const interface = 'logger';
export const dependencies = [];

export default class LoggerPlugin {
  constructor(config) {
    this.config = { level: 'info', ...config };
    this.logs = [];
  }
  
  async initialize(system) {
    this.system = system;
    system.addHook('app:log', this.log.bind(this), 1);
  }
  
  async activate() {
    console.log('Logger plugin activated');
  }
  
  async deactivate() {
    console.log('Logger plugin deactivated');
  }
  
  log(data) {
    const entry = {
      timestamp: new Date().toISOString(),
      level: data.level || 'info',
      message: data.message,
      source: data.source || 'unknown'
    };
    
    this.logs.push(entry);
    
    if (this.shouldLog(entry.level)) {
      console.log(`[${entry.timestamp}] ${entry.level.toUpperCase()}: ${entry.message}`);
    }
    
    return data;
  }
  
  shouldLog(level) {
    const levels = ['debug', 'info', 'warn', 'error'];
    const configLevel = levels.indexOf(this.config.level);
    const messageLevel = levels.indexOf(level);
    return messageLevel >= configLevel;
  }
  
  getLogs() {
    return [...this.logs];
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const pluginSystem = new PluginSystem();

// ì¸í„°í˜ì´ìŠ¤ ì •ì˜
pluginSystem.defineInterface('logger', ['log', 'getLogs']);

// í”ŒëŸ¬ê·¸ì¸ ë“±ë¡ ë° í™œì„±í™”
async function setupPlugins() {
  try {
    await pluginSystem.registerPlugin('logger', './plugins/logger.js', {
      level: 'info'
    });
    
    await pluginSystem.activatePlugin('logger');
    
    // í›… ì‹¤í–‰ í…ŒìŠ¤íŠ¸
    await pluginSystem.executeHook('app:log', {
      message: 'Application started',
      level: 'info',
      source: 'main'
    });
    
    console.log('Active plugins:', pluginSystem.getActivePlugins());
    
  } catch (error) {
    console.error('Plugin setup failed:', error);
  }
}

setupPlugins();
```

20.
```javascript
// ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ ëª¨ë“ˆ í˜ë”ë ˆì´ì…˜
class ModuleFederation {
  constructor(config = {}) {
    this.config = {
      name: 'host',
      remotes: {},
      shared: {},
      exposes: {},
      ...config
    };
    
    this.remoteModules = new Map();
    this.sharedModules = new Map();
    this.exposedModules = new Map();
    this.loadingPromises = new Map();
  }
  
  // ì›ê²© ëª¨ë“ˆ ë“±ë¡
  registerRemote(name, url, modules = {}) {
    this.remoteModules.set(name, {
      url,
      modules,
      loaded: false,
      container: null
    });
  }
  
  // ëª¨ë“ˆ ë…¸ì¶œ
  exposeModule(name, factory) {
    this.exposedModules.set(name, factory);
  }
  
  // ê³µìœ  ëª¨ë“ˆ ë“±ë¡
  shareModule(name, version, factory) {
    const key = `${name}@${version}`;
    this.sharedModules.set(key, {
      name,
      version,
      factory,
      instance: null,
      consumers: new Set()
    });
  }
  
  // ì›ê²© ëª¨ë“ˆ ë¡œë“œ
  async loadRemoteModule(remoteName, moduleName) {
    const cacheKey = `${remoteName}/${moduleName}`;
    
    if (this.loadingPromises.has(cacheKey)) {
      return this.loadingPromises.get(cacheKey);
    }
    
    const loadPromise = this.performRemoteLoad(remoteName, moduleName);
    this.loadingPromises.set(cacheKey, loadPromise);
    
    try {
      return await loadPromise;
    } finally {
      this.loadingPromises.delete(cacheKey);
    }
  }
  
  async performRemoteLoad(remoteName, moduleName) {
    const remoteInfo = this.remoteModules.get(remoteName);
    if (!remoteInfo) {
      throw new Error(`Remote ${remoteName} not found`);
    }
    
    // ì›ê²© ì»¨í…Œì´ë„ˆ ë¡œë“œ
    if (!remoteInfo.loaded) {
      await this.loadRemoteContainer(remoteName);
    }
    
    // ëª¨ë“ˆ íŒ©í† ë¦¬ ê°€ì ¸ì˜¤ê¸°
    const moduleFactory = await remoteInfo.container.get(moduleName);
    const module = moduleFactory();
    
    return module;
  }
  
  async loadRemoteContainer(remoteName) {
    const remoteInfo = this.remoteModules.get(remoteName);
    
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = remoteInfo.url;
      script.onload = () => {
        const containerName = `${remoteName}Container`;
        if (window[containerName]) {
          remoteInfo.container = window[containerName];
          remoteInfo.loaded = true;
          resolve();
        } else {
          reject(new Error(`Container ${containerName} not found`));
        }
      };
      script.onerror = () => reject(new Error(`Failed to load ${remoteInfo.url}`));
      document.head.appendChild(script);
    });
  }
  
  // ê³µìœ  ëª¨ë“ˆ ê°€ì ¸ì˜¤ê¸°
  async getSharedModule(name, version = 'latest') {
    const availableVersions = Array.from(this.sharedModules.keys())
      .filter(key => key.startsWith(`${name}@`))
      .map(key => key.split('@')[1]);
    
    if (availableVersions.length === 0) {
      throw new Error(`Shared module ${name} not found`);
    }
    
    const resolvedVersion = version === 'latest' 
      ? availableVersions.sort().pop()
      : version;
    
    const moduleKey = `${name}@${resolvedVersion}`;
    const moduleInfo = this.sharedModules.get(moduleKey);
    
    if (!moduleInfo) {
      throw new Error(`Shared module ${moduleKey} not found`);
    }
    
    if (!moduleInfo.instance) {
      moduleInfo.instance = await moduleInfo.factory();
    }
    
    moduleInfo.consumers.add(this.config.name);
    return moduleInfo.instance;
  }
  
  // ë²„ì „ í˜¸í™˜ì„± ê²€ì‚¬
  checkVersionCompatibility(requested, available) {
    // ê°„ë‹¨í•œ semver í˜¸í™˜ì„± ê²€ì‚¬
    const reqParts = requested.split('.').map(Number);
    const availParts = available.split('.').map(Number);
    
    // ë©”ì´ì € ë²„ì „ì´ ê°™ê³ , ë§ˆì´ë„ˆ ë²„ì „ì´ ê°™ê±°ë‚˜ ë” ë†’ìœ¼ë©´ í˜¸í™˜
    return reqParts[0] === availParts[0] && availParts[1] >= reqParts[1];
  }
  
  // ëª¨ë“ˆ ê°„ ìƒíƒœ ê³µìœ 
  createSharedState(name, initialState = {}) {
    const stateKey = `__shared_state_${name}`;
    
    if (!window[stateKey]) {
      window[stateKey] = {
        state: initialState,
        subscribers: new Set(),
        subscribe(callback) {
          this.subscribers.add(callback);
          return () => this.subscribers.delete(callback);
        },
        setState(newState) {
          this.state = { ...this.state, ...newState };
          this.subscribers.forEach(callback => callback(this.state));
        },
        getState() {
          return { ...this.state };
        }
      };
    }
    
    return window[stateKey];
  }
  
  // ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒì„±
  createModuleRegistry() {
    return {
      // ë…¸ì¶œëœ ëª¨ë“ˆ ì œê³µ
      get: async (moduleName) => {
        if (this.exposedModules.has(moduleName)) {
          return this.exposedModules.get(moduleName);
        }
        throw new Error(`Module ${moduleName} not exposed`);
      },
      
      // ê³µìœ  ëª¨ë“ˆ ì œê³µ
      shared: async (moduleName, version) => {
        return this.getSharedModule(moduleName, version);
      }
    };
  }
  
  // ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ ë¡œë”
  async loadMicrofrontend(name, selector, props = {}) {
    try {
      const MicrofrontendComponent = await this.loadRemoteModule(name, 'default');
      const container = document.querySelector(selector);
      
      if (!container) {
        throw new Error(`Container ${selector} not found`);
      }
      
      // ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ ë§ˆìš´íŠ¸
      const instance = new MicrofrontendComponent(props);
      if (typeof instance.mount === 'function') {
        await instance.mount(container);
      }
      
      return instance;
      
    } catch (error) {
      console.error(`Failed to load microfrontend ${name}:`, error);
      throw error;
    }
  }
  
  // í†µê³„ ë° ë””ë²„ê¹…
  getStats() {
    return {
      remotes: Array.from(this.remoteModules.keys()),
      shared: Array.from(this.sharedModules.keys()),
      exposed: Array.from(this.exposedModules.keys()),
      loadedRemotes: Array.from(this.remoteModules.values())
        .filter(r => r.loaded).length
    };
  }
}

// ì‚¬ìš© ì˜ˆì œ

// Host ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •
const federation = new ModuleFederation({
  name: 'shell',
  remotes: {
    'header-app': 'http://localhost:3001/headerApp.js',
    'content-app': 'http://localhost:3002/contentApp.js'
  }
});

// ê³µìœ  ëª¨ë“ˆ ë“±ë¡
federation.shareModule('react', '18.0.0', () => import('react'));
federation.shareModule('shared-utils', '1.0.0', () => import('./shared/utils'));

// ì›ê²© ì•± ë“±ë¡
federation.registerRemote('header-app', 'http://localhost:3001/remoteEntry.js', {
  'Header': './Header',
  'Navigation': './Navigation'
});

federation.registerRemote('content-app', 'http://localhost:3002/remoteEntry.js', {
  'default': './App',
  'ContentList': './ContentList'
});

// ê³µìœ  ìƒíƒœ ìƒì„±
const appState = federation.createSharedState('app', {
  user: null,
  theme: 'light'
});

// ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ ë¡œë“œ
async function loadApp() {
  try {
    // í—¤ë” ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ ë¡œë“œ
    const header = await federation.loadMicrofrontend('header-app', '#header', {
      onUserChange: (user) => appState.setState({ user })
    });
    
    // ì½˜í…ì¸  ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ ë¡œë“œ
    const content = await federation.loadMicrofrontend('content-app', '#content', {
      theme: appState.getState().theme
    });
    
    // ìƒíƒœ ë³€í™” ê°ì§€
    appState.subscribe((newState) => {
      console.log('App state changed:', newState);
      // í•„ìš”ì‹œ ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œì— ìƒíƒœ ì „íŒŒ
    });
    
    console.log('Federation stats:', federation.getStats());
    
  } catch (error) {
    console.error('Failed to load microfrontends:', error);
  }
}

loadApp();

// ì›ê²© ì•±ì—ì„œ ì‚¬ìš©í•  ì˜ˆì œ ì½”ë“œ
/*
// header-appì˜ webpack.config.js
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'headerApp',
      filename: 'remoteEntry.js',
      exposes: {
        './Header': './src/Header',
        './Navigation': './src/Navigation'
      },
      shared: {
        'react': { singleton: true },
        'shared-utils': { singleton: true }
      }
    })
  ]
};

// header-appì˜ Header ì»´í¬ë„ŒíŠ¸
export default class Header {
  constructor(props) {
    this.props = props;
  }
  
  async mount(container) {
    container.innerHTML = `
      <header>
        <h1>Microfrontend Header</h1>
        <nav>Navigation here</nav>
      </header>
    `;
  }
  
  unmount() {
    // ì •ë¦¬ ì‘ì—…
  }
}
*/
```