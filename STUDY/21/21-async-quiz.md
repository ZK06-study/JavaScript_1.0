# 21. ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° - í€´ì¦ˆ

## ê°ê´€ì‹ ë¬¸ì œ

### 1. ğŸŸ¢ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì´ í•„ìš”í•œ ì´ìœ ë¡œ ì˜¬ë°”ë¥¸ ê²ƒì€?
a) ì½”ë“œë¥¼ ë” ë³µì¡í•˜ê²Œ ë§Œë“¤ê¸° ìœ„í•´
b) ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•Šê¸° ìœ„í•´
c) ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ëŠ˜ë¦¬ê¸° ìœ„í•´
d) ì—ëŸ¬ë¥¼ ë” ì‰½ê²Œ ë§Œë“¤ê¸° ìœ„í•´

### 2. ğŸŸ¡ Promiseì˜ ìƒíƒœë¡œ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ê²ƒì€?
a) pending
b) fulfilled
c) rejected
d) waiting

### 3. ğŸŸ  `async` í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ì€?
a) í•­ìƒ undefined
b) í•­ìƒ Promise
c) í•¨ìˆ˜ ë‚´ì—ì„œ ë°˜í™˜í•˜ëŠ” ê°’
d) Error ê°ì²´

### 4. ğŸŸ¡ `await` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê³³ì€?
a) ëª¨ë“  í•¨ìˆ˜ ë‚´ë¶€
b) async í•¨ìˆ˜ ë‚´ë¶€ë§Œ
c) ì „ì—­ ìŠ¤ì½”í”„
d) ì½œë°± í•¨ìˆ˜ ë‚´ë¶€

### 5. ğŸŸ  `Promise.all()`ì˜ íŠ¹ì§•ìœ¼ë¡œ í‹€ë¦° ê²ƒì€?
a) ëª¨ë“  Promiseê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤
b) í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ê°€ ì‹¤íŒ¨í•œë‹¤
c) ê²°ê³¼ëŠ” ìˆœì„œëŒ€ë¡œ ë°˜í™˜ëœë‹¤
d) ê°€ì¥ ë¹ ë¥¸ Promiseì˜ ê²°ê³¼ë§Œ ë°˜í™˜í•œë‹¤

### 6. ğŸŸ¡ ì½œë°± ì§€ì˜¥(Callback Hell)ì„ í•´ê²°í•˜ëŠ” ë°©ë²•ì´ ì•„ë‹Œ ê²ƒì€?
a) Promise ì‚¬ìš©
b) async/await ì‚¬ìš©
c) ë” ë§ì€ ì¤‘ì²© ì½œë°± ì‚¬ìš©
d) í•¨ìˆ˜ ë¶„ë¦¬

## ë‹¨ë‹µí˜• ë¬¸ì œ

### 7. ğŸŸ¢ `setTimeout` í•¨ìˆ˜ì˜ ìµœì†Œ ì§€ì—° ì‹œê°„ì€ ëª‡ ë°€ë¦¬ì´ˆì¸ê°€?

### 8. ğŸŸ¡ Promiseì—ì„œ ì„±ê³µ ì‹œ í˜¸ì¶œë˜ëŠ” ë©”ì„œë“œëŠ”?

### 9. ğŸŸ  `Promise.race()`ëŠ” ì–´ë–¤ Promiseì˜ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ”ê°€?

### 10. ğŸŸ¢ `async` í•¨ìˆ˜ì—ì„œ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” êµ¬ë¬¸ì€?

## ì„œìˆ í˜• ë¬¸ì œ

### 11. ğŸŸ¡ ì½œë°±, Promise, async/awaitì˜ ì°¨ì´ì ê³¼ ê°ê°ì˜ ì¥ë‹¨ì ì„ ì„¤ëª…í•˜ì‹œì˜¤.

### 12. ğŸŸ  ì´ë²¤íŠ¸ ë£¨í”„(Event Loop)ì˜ ë™ì‘ ì›ë¦¬ì™€ ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ íì˜ ì—­í• ì„ ì„¤ëª…í•˜ì‹œì˜¤.

### 13. ğŸŸ¡ `Promise.all()`, `Promise.allSettled()`, `Promise.race()`ì˜ ì°¨ì´ì ì„ ì˜ˆì‹œì™€ í•¨ê»˜ ì„¤ëª…í•˜ì‹œì˜¤.

## ì½”ë”© ë¬¸ì œ

### 14. ğŸŸ¢ ë‹¤ìŒ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
```javascript
// 1. ì§€ì—° ì‹¤í–‰ í•¨ìˆ˜ (delay)
// 2. ì½œë°±ì„ Promiseë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ (promisify)
// 3. ê°„ë‹¨í•œ ë¹„ë™ê¸° ë°ì´í„° ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
```

### 15. ğŸŸ¡ Promise ì²´ì´ë‹ì„ async/awaitë¡œ ë³€í™˜í•˜ì‹œì˜¤.
```javascript
// ê¸°ì¡´ Promise ì²´ì´ë‹ ì½”ë“œ
fetch('/api/user')
  .then(response => response.json())
  .then(user => fetch(`/api/posts/${user.id}`))
  .then(response => response.json())
  .then(posts => console.log(posts))
  .catch(error => console.error(error));
```

### 16. ğŸŸ  ë³‘ë ¬ ì²˜ë¦¬ì™€ ìˆœì°¨ ì²˜ë¦¬ë¥¼ êµ¬í˜„í•˜ì‹œì˜¤.
```javascript
// ì—¬ëŸ¬ API í˜¸ì¶œì„ ë³‘ë ¬/ìˆœì°¨ë¡œ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜ë“¤
// ì‹¤í–‰ ì‹œê°„ ë¹„êµ í¬í•¨
```

### 17. ğŸŸ¡ ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
```javascript
// ì‹¤íŒ¨ ì‹œ ìë™ìœ¼ë¡œ ì¬ì‹œë„í•˜ëŠ” fetch í•¨ìˆ˜
// ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ì™€ ì§€ì—° ì‹œê°„ ì„¤ì • ê°€ëŠ¥
```

## ì‘ìš© ë¬¸ì œ

### 18. ğŸŸ  ë‹¤ìŒ ì½”ë“œì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì˜ˆìƒí•˜ê³  ì„¤ëª…í•˜ì‹œì˜¤.
```javascript
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');

Promise.resolve().then(() => {
  console.log('5');
  setTimeout(() => console.log('6'), 0);
});

console.log('7');
```

### 19. ğŸŸ  ì»¤ìŠ¤í…€ Promise êµ¬í˜„ì²´ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
```javascript
// MyPromise í´ë˜ìŠ¤
// then, catch, finally ë©”ì„œë“œ êµ¬í˜„
// ê¸°ë³¸ì ì¸ Promise ë™ì‘ ëª¨ë°©
```

### 20. ğŸŸ  ë¹„ë™ê¸° ì‘ì—… í ê´€ë¦¬ìë¥¼ êµ¬í˜„í•˜ì‹œì˜¤.
```javascript
// ë™ì‹œ ì‹¤í–‰ ì œí•œì´ ìˆëŠ” ë¹„ë™ê¸° ì‘ì—… í
// ìš°ì„ ìˆœìœ„ ì§€ì›
// ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§
```

---

## ì •ë‹µ

### ê°ê´€ì‹ ì •ë‹µ
1. b) ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•Šê¸° ìœ„í•´
2. d) waiting (Promise ìƒíƒœëŠ” pending, fulfilled, rejectedë§Œ ì¡´ì¬)
3. b) í•­ìƒ Promise
4. b) async í•¨ìˆ˜ ë‚´ë¶€ë§Œ (ES2022ì—ì„œ top-level await ì¶”ê°€ë¨)
5. d) ê°€ì¥ ë¹ ë¥¸ Promiseì˜ ê²°ê³¼ë§Œ ë°˜í™˜í•œë‹¤ (ì´ê²ƒì€ Promise.race()ì˜ íŠ¹ì§•)
6. c) ë” ë§ì€ ì¤‘ì²© ì½œë°± ì‚¬ìš©

### ë‹¨ë‹µí˜• ì •ë‹µ
7. 4ë°€ë¦¬ì´ˆ (ë¸Œë¼ìš°ì €ì—ì„œ ìµœì†Œ ì§€ì—° ì‹œê°„)
8. `then()`
9. ê°€ì¥ ë¨¼ì € ì™„ë£Œë˜ëŠ” Promise
10. `try/catch`

### ì„œìˆ í˜• ì •ë‹µ
11. **ì½œë°± vs Promise vs async/await:**

**ì½œë°±:**
- ì¥ì : ê°„ë‹¨í•œ êµ¬ì¡°, ì´í•´í•˜ê¸° ì‰¬ì›€
- ë‹¨ì : ì½œë°± ì§€ì˜¥, ì—ëŸ¬ ì²˜ë¦¬ ì–´ë ¤ì›€

**Promise:**
- ì¥ì : ì²´ì´ë‹ ê°€ëŠ¥, ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ , ìƒíƒœ ê´€ë¦¬
- ë‹¨ì : ì—¬ì „íˆ ë³µì¡í•  ìˆ˜ ìˆìŒ

**async/await:**
- ì¥ì : ë™ê¸°ì  ì½”ë“œì²˜ëŸ¼ ì‘ì„±, ê°€ë…ì„± ìµœê³ , ì—ëŸ¬ ì²˜ë¦¬ ê°„í¸
- ë‹¨ì : ES2017+, ë³‘ë ¬ ì²˜ë¦¬ ì‹œ ì£¼ì˜ í•„ìš”

12. **ì´ë²¤íŠ¸ ë£¨í”„ì™€ ë§ˆì´í¬ë¡œíƒœìŠ¤í¬:**
- **ì´ë²¤íŠ¸ ë£¨í”„**: ì½œ ìŠ¤íƒì´ ë¹„ì–´ìˆì„ ë•Œ íì—ì„œ ì‘ì—…ì„ ê°€ì ¸ì™€ ì‹¤í–‰
- **ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ í**: Promiseì˜ then/catch/finallyê°€ ëŒ€ê¸°í•˜ëŠ” ê³³
- **ìš°ì„ ìˆœìœ„**: ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ > ë§¤í¬ë¡œíƒœìŠ¤í¬ (setTimeout ë“±)

13. **Promise ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤:**
- **Promise.all()**: ëª¨ë“  Promise ì™„ë£Œ ëŒ€ê¸°, í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ ì‹¤íŒ¨
- **Promise.allSettled()**: ëª¨ë“  Promise ì™„ë£Œ ëŒ€ê¸°, ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
- **Promise.race()**: ê°€ì¥ ë¨¼ì € ì™„ë£Œë˜ëŠ” Promise ê²°ê³¼ ë°˜í™˜

### ì½”ë”© ì •ë‹µ
14.
```javascript
// 1. ì§€ì—° ì‹¤í–‰ í•¨ìˆ˜
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 2. ì½œë°±ì„ Promiseë¡œ ë³€í™˜
function promisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (error, result) => {
        if (error) reject(error);
        else resolve(result);
      });
    });
  };
}

// 3. ë¹„ë™ê¸° ë°ì´í„° ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return await response.json();
  } catch (error) {
    console.error('ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
    throw error;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
async function example() {
  await delay(1000); // 1ì´ˆ ëŒ€ê¸°
  console.log('1ì´ˆ í›„ ì‹¤í–‰ë¨');
  
  // Node.js fs.readFileì„ Promiseë¡œ ë³€í™˜
  // const readFile = promisify(fs.readFile);
  // const data = await readFile('file.txt', 'utf8');
  
  const userData = await fetchData('/api/user');
  console.log(userData);
}
```

15.
```javascript
// async/awaitë¡œ ë³€í™˜
async function fetchUserPosts() {
  try {
    const userResponse = await fetch('/api/user');
    const user = await userResponse.json();
    
    const postsResponse = await fetch(`/api/posts/${user.id}`);
    const posts = await postsResponse.json();
    
    console.log(posts);
    return posts;
  } catch (error) {
    console.error(error);
    throw error;
  }
}

// ë” ê°„ê²°í•œ ë²„ì „ (ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨)
async function fetchUserPostsSimple() {
  try {
    const user = await fetch('/api/user').then(res => res.json());
    const posts = await fetch(`/api/posts/${user.id}`).then(res => res.json());
    
    console.log(posts);
    return posts;
  } catch (error) {
    console.error(error);
    throw error;
  }
}

// ì‚¬ìš©
fetchUserPosts();
```

16.
```javascript
// ë³‘ë ¬ ì²˜ë¦¬ vs ìˆœì°¨ ì²˜ë¦¬
async function compareExecution() {
  const urls = [
    '/api/data1',
    '/api/data2', 
    '/api/data3'
  ];
  
  // ë³‘ë ¬ ì²˜ë¦¬ (ëª¨ë“  ìš”ì²­ì„ ë™ì‹œì— ì‹œì‘)
  async function fetchParallel() {
    console.time('ë³‘ë ¬ ì²˜ë¦¬');
    
    const promises = urls.map(url => fetch(url).then(res => res.json()));
    const results = await Promise.all(promises);
    
    console.timeEnd('ë³‘ë ¬ ì²˜ë¦¬');
    return results;
  }
  
  // ìˆœì°¨ ì²˜ë¦¬ (í•˜ë‚˜ì”© ìˆœì„œëŒ€ë¡œ)
  async function fetchSequential() {
    console.time('ìˆœì°¨ ì²˜ë¦¬');
    
    const results = [];
    for (const url of urls) {
      const response = await fetch(url);
      const data = await response.json();
      results.push(data);
    }
    
    console.timeEnd('ìˆœì°¨ ì²˜ë¦¬');
    return results;
  }
  
  // ë³‘ë ¬ ì²˜ë¦¬ (ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ )
  async function fetchParallelSafe() {
    console.time('ì•ˆì „í•œ ë³‘ë ¬ ì²˜ë¦¬');
    
    const results = await Promise.allSettled(
      urls.map(async (url) => {
        try {
          const response = await fetch(url);
          return await response.json();
        } catch (error) {
          return { error: error.message, url };
        }
      })
    );
    
    console.timeEnd('ì•ˆì „í•œ ë³‘ë ¬ ì²˜ë¦¬');
    return results;
  }
  
  // ì œí•œëœ ë™ì‹œì„± (ìµœëŒ€ 2ê°œì”©ë§Œ ë™ì‹œ ì‹¤í–‰)
  async function fetchWithConcurrencyLimit(limit = 2) {
    console.time('ì œí•œëœ ë™ì‹œì„±');
    
    const results = [];
    for (let i = 0; i < urls.length; i += limit) {
      const batch = urls.slice(i, i + limit);
      const batchResults = await Promise.all(
        batch.map(url => fetch(url).then(res => res.json()))
      );
      results.push(...batchResults);
    }
    
    console.timeEnd('ì œí•œëœ ë™ì‹œì„±');
    return results;
  }
  
  return {
    fetchParallel,
    fetchSequential,
    fetchParallelSafe,
    fetchWithConcurrencyLimit
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
// const fetchers = compareExecution();
// await fetchers.fetchParallel(); // ê°€ì¥ ë¹ ë¦„
// await fetchers.fetchSequential(); // ê°€ì¥ ëŠë¦¼
```

17.
```javascript
// ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ fetch í•¨ìˆ˜
async function fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
  const {
    retryDelay = delay,
    retryMultiplier = 2,
    retryCondition = (error) => true,
    onRetry = null,
    ...fetchOptions
  } = options;
  
  let lastError;
  let currentDelay = retryDelay;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, fetchOptions);
      
      // HTTP ì—ëŸ¬ ìƒíƒœ ì½”ë“œ ì²´í¬
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      lastError = error;
      
      // ë§ˆì§€ë§‰ ì‹œë„ì˜€ë‹¤ë©´ ì—ëŸ¬ throw
      if (attempt === maxRetries) {
        throw error;
      }
      
      // ì¬ì‹œë„ ì¡°ê±´ í™•ì¸
      if (!retryCondition(error)) {
        throw error;
      }
      
      // ì¬ì‹œë„ ì½œë°± í˜¸ì¶œ
      if (onRetry) {
        onRetry(error, attempt + 1, maxRetries);
      }
      
      console.log(`ì¬ì‹œë„ ${attempt + 1}/${maxRetries}: ${currentDelay}ms í›„ ì¬ì‹œë„`);
      
      // ì§€ì—° í›„ ì¬ì‹œë„
      await new Promise(resolve => setTimeout(resolve, currentDelay));
      currentDelay *= retryMultiplier;
    }
  }
  
  throw lastError;
}

// ì‚¬ìš©í•˜ê¸° ì‰¬ìš´ ë˜í¼ í•¨ìˆ˜ë“¤
async function fetchJSON(url, options = {}) {
  const response = await fetchWithRetry(url, {
    ...options,
    onRetry: (error, attempt, maxAttempts) => {
      console.log(`ğŸ”„ ì¬ì‹œë„ ì¤‘... (${attempt}/${maxAttempts})`);
    }
  });
  return await response.json();
}

async function fetchWithExponentialBackoff(url, options = {}) {
  return await fetchWithRetry(url, {
    retryDelay: 1000,
    retryMultiplier: 2,
    retryCondition: (error) => {
      // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ë‚˜ 5xx ì„œë²„ ì—ëŸ¬ë§Œ ì¬ì‹œë„
      return error.message.includes('fetch') || 
             error.message.includes('5');
    },
    ...options
  });
}

// ì‚¬ìš© ì˜ˆì‹œ
async function example() {
  try {
    const data = await fetchJSON('/api/unreliable-endpoint', {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });
    console.log('ë°ì´í„°:', data);
  } catch (error) {
    console.error('ìµœì¢… ì‹¤íŒ¨:', error.message);
  }
}
```

### ì‘ìš© ì •ë‹µ
18.
```javascript
// ì‹¤í–‰ ìˆœì„œ:
// 1, 4, 7, 3, 5, 2, 6

// ì„¤ëª…:
// 1. '1' ì¶œë ¥ (ë™ê¸°)
// 2. setTimeoutì´ íƒœìŠ¤í¬ íì— ì¶”ê°€
// 3. Promise.resolve().thenì´ ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ íì— ì¶”ê°€
// 4. '4' ì¶œë ¥ (ë™ê¸°)
// 5. ë˜ ë‹¤ë¥¸ Promiseê°€ ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ íì— ì¶”ê°€
// 6. '7' ì¶œë ¥ (ë™ê¸°)
// 7. ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ í ì²˜ë¦¬: '3' ì¶œë ¥
// 8. ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ í ì²˜ë¦¬: '5' ì¶œë ¥ ë° ìƒˆ setTimeout ë“±ë¡
// 9. íƒœìŠ¤í¬ í ì²˜ë¦¬: '2' ì¶œë ¥
// 10. íƒœìŠ¤í¬ í ì²˜ë¦¬: '6' ì¶œë ¥
```

19.
```javascript
// ì»¤ìŠ¤í…€ Promise êµ¬í˜„
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    
    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(callback => callback());
      }
    };
    
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(callback => callback());
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      const handleFulfilled = () => {
        try {
          if (typeof onFulfilled === 'function') {
            const result = onFulfilled(this.value);
            resolve(result);
          } else {
            resolve(this.value);
          }
        } catch (error) {
          reject(error);
        }
      };
      
      const handleRejected = () => {
        try {
          if (typeof onRejected === 'function') {
            const result = onRejected(this.reason);
            resolve(result);
          } else {
            reject(this.reason);
          }
        } catch (error) {
          reject(error);
        }
      };
      
      if (this.state === 'fulfilled') {
        setTimeout(handleFulfilled, 0);
      } else if (this.state === 'rejected') {
        setTimeout(handleRejected, 0);
      } else {
        this.onFulfilledCallbacks.push(handleFulfilled);
        this.onRejectedCallbacks.push(handleRejected);
      }
    });
  }
  
  catch(onRejected) {
    return this.then(null, onRejected);
  }
  
  finally(onFinally) {
    return this.then(
      value => {
        onFinally();
        return value;
      },
      reason => {
        onFinally();
        throw reason;
      }
    );
  }
  
  static resolve(value) {
    return new MyPromise(resolve => resolve(value));
  }
  
  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }
  
  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const results = [];
      let completedCount = 0;
      
      if (promises.length === 0) {
        resolve(results);
        return;
      }
      
      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          value => {
            results[index] = value;
            completedCount++;
            if (completedCount === promises.length) {
              resolve(results);
            }
          },
          reject
        );
      });
    });
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => resolve('ì„±ê³µ!'), 1000);
});

promise
  .then(value => {
    console.log(value); // 'ì„±ê³µ!'
    return value + ' ì¶”ê°€';
  })
  .then(value => {
    console.log(value); // 'ì„±ê³µ! ì¶”ê°€'
  })
  .catch(error => {
    console.error(error);
  })
  .finally(() => {
    console.log('ì™„ë£Œ');
  });
```

20.
```javascript
// ë¹„ë™ê¸° ì‘ì—… í ê´€ë¦¬ì
class AsyncTaskQueue {
  constructor(maxConcurrency = 3) {
    this.maxConcurrency = maxConcurrency;
    this.running = 0;
    this.queue = [];
    this.results = new Map();
    this.listeners = new Set();
  }
  
  // ì‘ì—… ì¶”ê°€
  add(task, priority = 0, id = null) {
    const taskWrapper = {
      id: id || Date.now() + Math.random(),
      task,
      priority,
      status: 'pending',
      result: null,
      error: null,
      addedAt: Date.now(),
      startedAt: null,
      completedAt: null
    };
    
    // ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬í•˜ì—¬ ì‚½ì…
    const insertIndex = this.queue.findIndex(item => item.priority < priority);
    if (insertIndex === -1) {
      this.queue.push(taskWrapper);
    } else {
      this.queue.splice(insertIndex, 0, taskWrapper);
    }
    
    this.notifyListeners('taskAdded', taskWrapper);
    this.processQueue();
    
    return taskWrapper.id;
  }
  
  // í ì²˜ë¦¬
  async processQueue() {
    while (this.running < this.maxConcurrency && this.queue.length > 0) {
      const taskWrapper = this.queue.shift();
      this.executeTask(taskWrapper);
    }
  }
  
  // ê°œë³„ ì‘ì—… ì‹¤í–‰
  async executeTask(taskWrapper) {
    this.running++;
    taskWrapper.status = 'running';
    taskWrapper.startedAt = Date.now();
    
    this.notifyListeners('taskStarted', taskWrapper);
    
    try {
      const result = await taskWrapper.task();
      taskWrapper.status = 'completed';
      taskWrapper.result = result;
      taskWrapper.completedAt = Date.now();
      
      this.results.set(taskWrapper.id, {
        success: true,
        result,
        duration: taskWrapper.completedAt - taskWrapper.startedAt
      });
      
      this.notifyListeners('taskCompleted', taskWrapper);
    } catch (error) {
      taskWrapper.status = 'failed';
      taskWrapper.error = error;
      taskWrapper.completedAt = Date.now();
      
      this.results.set(taskWrapper.id, {
        success: false,
        error,
        duration: taskWrapper.completedAt - taskWrapper.startedAt
      });
      
      this.notifyListeners('taskFailed', taskWrapper);
    } finally {
      this.running--;
      this.processQueue(); // ë‹¤ìŒ ì‘ì—… ì²˜ë¦¬
    }
  }
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ê´€ë¦¬
  on(event, listener) {
    this.listeners.add({ event, listener });
  }
  
  off(event, listener) {
    this.listeners.delete({ event, listener });
  }
  
  notifyListeners(event, data) {
    this.listeners.forEach(({ event: listenerEvent, listener }) => {
      if (listenerEvent === event) {
        listener(data);
      }
    });
  }
  
  // ìƒíƒœ ì¡°íšŒ
  getStatus() {
    return {
      running: this.running,
      queued: this.queue.length,
      maxConcurrency: this.maxConcurrency,
      totalCompleted: this.results.size
    };
  }
  
  // ê²°ê³¼ ì¡°íšŒ
  getResult(taskId) {
    return this.results.get(taskId);
  }
  
  // ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
  async waitForAll() {
    return new Promise((resolve) => {
      const checkCompletion = () => {
        if (this.running === 0 && this.queue.length === 0) {
          resolve(Array.from(this.results.values()));
        } else {
          setTimeout(checkCompletion, 100);
        }
      };
      checkCompletion();
    });
  }
  
  // í ì •ë¦¬
  clear() {
    this.queue = [];
    this.results.clear();
  }
  
  // í†µê³„
  getStats() {
    const results = Array.from(this.results.values());
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);
    
    return {
      total: results.length,
      successful: successful.length,
      failed: failed.length,
      averageDuration: results.length > 0 ? 
        results.reduce((sum, r) => sum + r.duration, 0) / results.length : 0,
      successRate: results.length > 0 ? 
        (successful.length / results.length) * 100 : 0
    };
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const queue = new AsyncTaskQueue(2); // ìµœëŒ€ 2ê°œ ë™ì‹œ ì‹¤í–‰

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
queue.on('taskCompleted', (task) => {
  console.log(`âœ… ì‘ì—… ì™„ë£Œ: ${task.id}`);
});

queue.on('taskFailed', (task) => {
  console.log(`âŒ ì‘ì—… ì‹¤íŒ¨: ${task.id}`, task.error.message);
});

// ì‘ì—…ë“¤ ì¶”ê°€
const taskId1 = queue.add(
  () => new Promise(resolve => setTimeout(() => resolve('ê²°ê³¼1'), 2000)),
  1, // ë‚®ì€ ìš°ì„ ìˆœìœ„
  'task1'
);

const taskId2 = queue.add(
  () => new Promise(resolve => setTimeout(() => resolve('ê²°ê³¼2'), 1000)),
  5, // ë†’ì€ ìš°ì„ ìˆœìœ„ (ë¨¼ì € ì‹¤í–‰ë¨)
  'task2'
);

const taskId3 = queue.add(
  () => new Promise((_, reject) => setTimeout(() => reject(new Error('ì‹¤íŒ¨')), 500)),
  3,
  'task3'
);

// ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
async function monitorQueue() {
  console.log('í ëª¨ë‹ˆí„°ë§ ì‹œì‘');
  
  const interval = setInterval(() => {
    console.log('í˜„ì¬ ìƒíƒœ:', queue.getStatus());
  }, 500);
  
  await queue.waitForAll();
  clearInterval(interval);
  
  console.log('ëª¨ë“  ì‘ì—… ì™„ë£Œ');
  console.log('í†µê³„:', queue.getStats());
  
  // ê°œë³„ ê²°ê³¼ í™•ì¸
  console.log('Task1 ê²°ê³¼:', queue.getResult('task1'));
  console.log('Task2 ê²°ê³¼:', queue.getResult('task2'));
  console.log('Task3 ê²°ê³¼:', queue.getResult('task3'));
}

monitorQueue();
```