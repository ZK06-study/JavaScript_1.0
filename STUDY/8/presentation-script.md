````markdown
# 함수

프로그래밍에서의 함수란, **큰 프로그램을 잘게 쪼개어 특정 코드 뭉치를 반복해서 사용할 수 있도록 묶어놓은 코드 뭉치의 단위**를 말합니다. 함수를 어떻게 작성하느냐에 따라서 코드의 유지보수성과 가독성이 크게 달라집니다. 또 JavaScript의 함수는 굉장히 많은 기능을 갖고 있는데, 사실 함수의 성질을 모두 이해하면 프로그래밍 언어로서의 JavaScript를 전부 이해한거나 마찬가지라고 할 수 있을 정도입니다. 본 챕터에서는 함수의 기본적인 성질만을 다루고, 이어지는 챕터들에서 나머지 내용을 차근차근 다룰 것입니다.

---

## 함수의 구성 요소

두 값을 더하는 아주 간단한 함수를 정의해 보겠습니다.

```js
function add(x, y) {
  const result = x + y;
  return result;
}
```

위에서 `add`라는 **이름**을 갖는 함수를 정의했습니다. 괄호 안의 `x`와 `y`를 **매개변수(parameter)**라 하며, `return` 뒤에 오는 값을 **반환값(return value)**이라고 합니다.

함수를 정의했다면, 아래와 같이 함수 이름 뒤에 괄호를 붙여서 이 함수를 실행시킬 수 있습니다. 이를 함수의 **호출(function call)**이라고 합니다.

```js
add(2, 3); // 5
```

여기서 괄호 안에 넘겨준 `2`, `3`을 **인수(argument)**라고 부릅니다.

---

### 실행 순서

JavaScript는 기본적으로는 쓰여진 순서대로 실행되지만, 여러 가지 예외가 존재해서 코드의 실행 순서가 이리저리 옮겨다니기도 합니다. 함수 호출도 그 중 하나로, 함수 호출 코드를 만나면 코드의 실행 흐름이 호출된 함수의 내부로 옮겨갑니다. 함수가 값을 반환하면 다시 이전 위치부터 코드의 실행이 재개됩니다.

```js
// 1 - 함수 정의
function add(x, y) {
  return x + y; // 3 - 함수 실행
}
// 2 - 함수 호출
const result = add(2, 3);
// 4 - 나머지 코드 실행
console.log(result);
```

여기서 유의할 점은, 함수를 정의하는 것만으로는 함수 내부에 있는 코드가 실행되지 않는다는 것입니다. 함수 내부의 코드를 실행하려면, 반드시 함수를 호출해주어야 합니다.

---

### 매개변수와 인수

위 코드의 `x`와 `y`를 가지고 **매개변수**라고 합니다. 매개변수는 변수의 일종으로, 함수 호출 시마다 인수가 매개변수에 대입됩니다. 위의 코드에서 `add(2, 3)`과 같이 호출하면 매개변수 `x`에는 `2`가, `y`에는 `3`이 대입된 채로 나머지 코드가 실행됩니다.

여기서 주의할 점은 매개변수는 바깥에서 선언된 변수와는 관계없는 독립적인 변수라는 것입니다. 예를 들어, 함수 호출 시 인수가 들어갈 자리에 변수를 써주고, 함수 내부에서 매개변수에 새로운 값을 대입한다고 하더라도 인수로 써준 변수의 값이 변경되지 않습니다.

```js
function reassign(x) {
  x = 2;
  return x;
}

const y = 1;
const result = reassign(y);

console.log(y); // 1
console.log(result); // 2
```

---

### 반환값

`return` 구문은 함수의 반환값을 결정합니다. `return` 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며, 반환되는 즉시 함수 실행이 끝납니다.

```js
function add(x, y) {
  return x + y;
  console.log('이 부분은 실행되지 않습니다.');
}
add(1, 2); // 3
// 3 외에 따로 출력되는 내용이 없습니다.
```

아래와 같이 `return` 뒤에 아무 값도 써주지 않거나, 아예 `return` 구문을 쓰지 않으면 함수는 `undefined`를 반환합니다.

```js
function returnUndefined() {
  return;
}
function noReturn() {}
returnUndefined(); // undefined
noReturn(); // undefined
```

---

## 스코프 (Scope)

함수의 매개변수를 비롯한, 모든 변수들은 특별한 성질을 갖습니다.

```js
function add(x, y) { // 변수 `x`와 `y`가 정의됨
  return x + y;
}
add(2, 3);
console.log(x); // 에러!
```

이렇게, 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있습니다. 즉, **변수는 코드의 일정 범위 안에서만 유효하다**는 성질이 있는 것입니다. 이렇게, 특정 변수가 유효한 코드 상의 **유효 범위**를 가지고 **스코프(scope)**라고 합니다.

---

### 스코프 연쇄 (Scope Chain)

함수 내부 코드에서, 매개변수 혹은 그 함수 안에서 정의된 변수만 사용할 수 있는 것은 아닙니다.

```js
const five = 5;
function add5(x) {
  return x + five; // 바깥 스코프의 `five` 변수에 접근
}
add5(3); // 8
```

`add5` 함수의 `return` 구문에서 함수 바깥에 있는 변수 `five`의 값을 가져와 사용했습니다. 이는 심지어 함수가 여러 겹 중첩(nested)되어 있다고 하더라도 가능합니다.

```js
const five = 5;
function add5(x) {
  function add(y) {
    return x + y;
  }
  return add(five);
}
add5(3); // 8
```

---

### 변수 가리기 (Variable Shadowing)

단일 스코프에서는 같은 이름을 갖는 서로 다른 변수가 존재할 수 없습니다. 하지만 스코프 연쇄가 일어나면 이야기가 달라집니다. 아래의 코드에서는 `x`라는 이름을 갖는 변수가 세 번 정의되었습니다.

```js
const x = 3;

function add5(x) { // `x`라는 변수가 다시 정의됨
  function add(x, y) { // `x`라는 변수가 다시 정의됨
    return x + y;
  }
  return add(x, 5);
}

add5(x);
```

위와 같이, 바깥쪽 스코프에 존재하는 변수와 같은 이름을 갖는 변수를 안쪽 스코프에서 재정의할 수 있습니다. 그렇게 되면 안쪽 스코프에서는 바깥쪽 스코프에 있는 이름이 **무시**됩니다. 이런 현상을 **변수 가리기(variable shadowing)**라고 합니다.

---

### 어휘적 스코핑 (Lexical Scoping)

스코프는 **코드가 작성된 구조**에 의해서 결정되는 것이지, **함수 호출의 형태**에 의해 결정되는 것이 아닙니다. 예를 들어 봅시다.

```js
function add5(x) {
  const five = 5;
  return add(x);
}

add5(3); // 8

function add(x) {
  return five + x; // ReferenceError: five is not defined
}
```

`add`라는 함수가 `add5`라는 함수 안에서 **호출**되었다고 해서, `add` 함수 내부에서 `add5` 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아닙니다. 스코프는 코드가 **작성**된 구조에 의해 결정되는 성질입니다. 위 코드를 동작시키려면, 아래와 같이 작성해야 합니다.

```js
function add5(x) {
  const five = 5;
  function add(x) {
    return five + x;
  }
  return add(x);
}
```

---

## 값으로서의 함수

JavaScript에서는 함수도 값입니다!

```js
function add(x, y) {
  return x + y;
}

const plus = add;
plus(1, 2); // 3
```

다른 값과 마찬가지로, 함수를 선언한 뒤 변수에 대입해서 호출할 수도 있고, 혹은 배열이나 객체에 넣을 수도 있고, 심지어는 함수를 다른 함수에 인수로 넘기거나, 함수에서 함수를 반환할 수도 있습니다.

---

## 익명 함수 (Anonymous Function)

JavaScript에서 함수를 선언할 때 꼭 **이름**을 붙여주어야 하는 것은 아닙니다. 아래와 같이 이름을 붙이지 않은 함수를 가지고 **익명 함수(anonymous function)**, 혹은 함수 리터럴(function literal)이라고 합니다.

```js
// 두 수를 더해서 반환하는 익명 함수
function(x, y) {
  return x + y;
}
// 위의 익명 함수는 이름이 없어서 이름을 가지고 호출을 할 수 없습니다.

// 호출을 하려면 변수에 저장한 후에 변수의 이름을 통해 호출해야 합니다.
const add = function(x, y) {
  return x + y;
}
add(1, 2); // 3
```

---

## 화살표 함수 (Arrow Function)

함수 정의를 위한 새로운 표기법인 화살표 함수(arrow function)은 ES2015에서 도입되었습니다.

```js
// 여기에서 x + y 는 **바로 반환됩니다.**
const add = (x, y) => x + y;
```

```js
// 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces({...}) 로 둘러싸주어야 합니다.
// `=>` 다음 부분을 중괄호로 둘러싸면, 명시적으로 `return` 하지 않는 한 아무것도 반환되지 않습니다.
const add = (x, y) => {
  const result = x + y;
  return result;
}
```

---

# 퀴즈

## 객관식 문제

1.  함수의 매개변수와 인수에 대한 설명으로 옳은 것은?
    a) 매개변수와 인수는 같은 의미이다
    b) 매개변수는 함수 정의 시, 인수는 함수 호출 시 사용된다
    c) 인수는 함수 정의 시, 매개변수는 함수 호출 시 사용된다
    d) 매개변수는 숫자만, 인수는 문자열만 가능하다

2.  `return` 구문에 대한 설명으로 옳지 않은 것은?
    a) 함수의 반환값을 결정한다
    b) return 실행 즉시 함수가 종료된다
    c) return 구문이 없으면 에러가 발생한다
    d) return 뒤에 값이 없으면 undefined를 반환한다

---

## 코딩 문제

1.  두 숫자를 더하는 함수를 작성하시오.

```js
function add(a, b) {
  return a + b;
}
```

2.  이름을 매개변수로 받아 인사말을 반환하는 함수를 작성하시오.

```js
function greet(name) {
  return '안녕하세요, ' + name + '님!';
}
```

3.  화살표 함수를 사용하여 숫자를 제곱하는 함수를 작성하시오.

```js
const square = x => x * x;
```
````