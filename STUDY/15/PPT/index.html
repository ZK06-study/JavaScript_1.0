<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[15장] 연산자 심층 탐구</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="progress-bar"></div>

    <main id="presentation-container">
        <!-- Slide 1: Title -->
        <section class="slide active" data-slide-id="0">
            <div class="slide-content">
                <h1><i class="fa-solid fa-calculator"></i> 15장. 연산자 심층 탐구</h1>
                <p class="subtitle">코드의 품질을 높이는 연산자의 숨겨진 동작 원리</p>
                <div class="keywords">
                    <span>#비교연산자</span>
                    <span>#논리연산자</span>
                    <span>#단축평가</span>
                    <span>#옵셔널체이닝</span>
                </div>
            </div>
        </section>

        <!-- Slide 2: Arithmetic Operators -->
        <section class="slide" data-slide-id="1">
            <div class="slide-content">
                <h2><i class="fa-solid fa-plus-minus"></i> 산술 연산자와 '+'의 두 얼굴</h2>
                <p>가장 기본적인 산술 연산자, 하지만 `+` 연산자는 특별한 비밀을 가지고 있습니다.</p>
                <div class="comparison-container">
                    <div class="code-block">
                        <h4><i class="fa-solid fa-hashtag"></i> 덧셈 연산</h4>
                        <pre><code>1 + 2;      // 3
1 + true;   // 2 (true는 1로 변환)
1 + null;   // 1 (null은 0으로 변환)</code></pre>
                    </div>
                    <div class="code-block">
                        <h4><i class="fa-solid fa-font"></i> 문자열 연결</h4>
                        <pre><code>'1' + 2;      // "12"
'1' + true;   // "1true"
'1' + null;   // "1null"</code></pre>
                    </div>
                </div>
                <p class="highlight">피연산자 중 하나라도 문자열이 있으면, 다른 모든 값을 문자열로 바꾸어 연결합니다.</p>
            </div>
        </section>

        <!-- Slide 3: Equality -->
        <section class="slide" data-slide-id="2">
            <div class="slide-content">
                <h2><i class="fa-solid fa-scale-unbalanced-flip"></i> 비교의 기술: <code>==</code> vs <code>===</code></h2>
                <p>동등 비교(<code>==</code>)는 타입을 변환하지만, 일치 비교(<code>===</code>)는 타입과 값 모두를 엄격하게 검사합니다.</p>
                <div class="comparison-container">
                    <div class="code-block bad">
                        <h4><i class="fa-solid fa-circle-xmark"></i> 동등 비교 (==)</h4>
                        <pre><code>5 == '5'         // true
'0' == false     // true
null == undefined // true</code></pre>
                    </div>
                    <div class="code-block good">
                        <h4><i class="fa-solid fa-circle-check"></i> 일치 비교 (===)</h4>
                        <pre><code>5 === '5'         // false
'0' === false     // false
null === undefined // false</code></pre>
                    </div>
                </div>
                <p class="highlight"><i class="fa-solid fa-shield-halved"></i> 예측 불가능한 버그를 피하기 위해 항상 <code>===</code>를 사용하세요.</p>
            </div>
        </section>

        <!-- Slide 4: Truthy & Falsy -->
        <section class="slide" data-slide-id="3">
            <div class="slide-content">
                <h2><i class="fa-solid fa-ghost"></i> 참 같은 값, 거짓 같은 값 (Truthy & Falsy)</h2>
                <p>자바스크립트에서는 7개의 Falsy 값을 제외한 모든 것이 Truthy 값으로 평가됩니다.</p>
                <div class="falsy-values">
                    <span class="falsy-item">false</span>
                    <span class="falsy-item">undefined</span>
                    <span class="falsy-item">null</span>
                    <span class="falsy-item">0, -0</span>
                    <span class="falsy-item">NaN</span>
                    <span class="falsy-item">'' (빈 문자열)</span>
                </div>
                <p class="note">놀랍게도, 빈 객체 <code>{}</code> 와 빈 배열 <code>[]</code> 는 Truthy 값입니다!</p>
            </div>
        </section>

        <!-- Slide 5: Truthy/Falsy Checker -->
        <section class="slide" data-slide-id="4">
            <div class="slide-content">
                <h2><i class="fa-solid fa-flask-vial"></i> 인터랙티브: Truthy/Falsy 체커</h2>
                <p>궁금한 값을 입력하거나 버튼을 눌러 Truthy/Falsy 여부를 직접 확인해보세요.</p>
                <div id="truthy-checker" class="interactive-demo-vertical">
                    <div class="input-area">
                        <input type="text" id="truthy-input" placeholder="e.g., 'hello', 0, [], {}">
                        <button id="truthy-check-btn" class="demo-btn">확인</button>
                    </div>
                    <div class="preset-area">
                        <button class="preset-btn">'hello'</button>
                        <button class="preset-btn">0</button>
                        <button class="preset-btn">[]</button>
                        <button class="preset-btn">{}</button>
                        <button class="preset-btn">undefined</button>
                        <button class="preset-btn">null</button>
                    </div>
                    <div id="truthy-output" class="output-area">
                        <p>결과가 여기에 표시됩니다.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 6: Short Circuit -->
        <section class="slide" data-slide-id="5">
            <div class="slide-content">
                <h2><i class="fa-solid fa-bolt-lightning"></i> 똑똑한 논리 연산자 (단축 평가)</h2>
                <p>논리 연산자 <code>&&</code>와 <code>||</code>는 평가를 조기에 중단하여 코드를 간결하게 만듭니다.</p>
                <div class="comparison-container">
                    <div class="code-block">
                        <h4><code>A && B</code> (AND)</h4>
                        <p>A가 Falsy면 A를 반환, 아니면 B를 반환</p>
                        <pre><code>isLoggedIn && showProfile();
// if (isLoggedIn) { showProfile(); }</code></pre>
                    </div>
                    <div class="code-block">
                        <h4><code>A || B</code> (OR)</h4>
                        <p>A가 Truthy면 A를 반환, 아니면 B를 반환</p>
                        <pre><code>const name = savedName || 'Guest';
// let name = savedName ? savedName : 'Guest';</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 7: Short Circuit Simulator -->
        <section class="slide" data-slide-id="6">
            <div class="slide-content">
                <h2><i class="fa-solid fa-gears"></i> 인터랙티브: 단축 평가 시뮬레이터</h2>
                <p>버튼을 눌러 각 표현식의 평가 과정과 최종 결과를 확인해보세요.</p>
                <div id="sc-demo" class="interactive-demo-vertical">
                    <div class="sc-expressions">
                        <button class="demo-btn sc-btn" data-expr="true && 'Dog'">true && 'Dog'</button>
                        <button class="demo-btn sc-btn" data-expr="false && 'Dog'">false && 'Dog'</button>
                        <button class="demo-btn sc-btn" data-expr="'Cat' || 'Dog'">'Cat' || 'Dog'</button>
                        <button class="demo-btn sc-btn" data-expr="null || 'Default'">null || 'Default'</button>
                    </div>
                    <div id="sc-output" class="output-area">
                        <div class="sc-box" id="sc-left">A</div>
                        <div class="sc-op" id="sc-operator"></div>
                        <div class="sc-box" id="sc-right">B</div>
                        <div class="sc-result" id="sc-final-result">결과</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 8: Optional Chaining -->
        <section class="slide" data-slide-id="7">
            <div class="slide-content">
                <h2><i class="fa-solid fa-link-slash"></i> 에러 방지의 제왕, 옵셔널 체이닝 `?.`</h2>
                <p>중첩된 객체의 속성에 접근할 때 `null`이나 `undefined`를 만나도 에러 없이 안전하게 `undefined`를 반환합니다.</p>
                 <pre><code>const user = {
  name: 'John',
  // address는 없는 상태
};

// ?. 를 사용하지 않으면...
// const street = user.address.street; // 💥 TypeError!

// ?. 를 사용하면...
const street = user.address?.street; // street는 undefined (에러 없음)
const country = user.address?.country ?? 'Korea'; // ??와 함께 사용 (country는 'Korea')

// 함수 호출에도 사용 가능
user.nonExistentMethod?.(); // 에러 없이 조용히 넘어감</code></pre>
            </div>
        </section>
        
        <!-- Slide 9: Nullish Coalescing -->
        <section class="slide" data-slide-id="8">
            <div class="slide-content">
                <h2><i class="fa-solid fa-circle-question"></i> 기본값 설정 전문가, null 병합 `??`</h2>
                <p>오직 <code>null</code>과 <code>undefined</code>만 걸러내고, 나머지 값은 그대로 반환하는 스마트한 기본값 설정 연산자입니다.</p>
                <div class="comparison-container">
                    <div class="code-block bad">
                        <h4><code>||</code>의 함정</h4>
                        <pre><code>let count = 0;
// count가 0(falsy)이라서 의도와 다르게 10이 할당됨
const finalCount = count || 10; // 10</code></pre>
                    </div>
                    <div class="code-block good">
                        <h4><code>??</code>의 스마트함</h4>
                        <pre><code>let count = 0;
// count가 null/undefined가 아니므로 0이 그대로 할당됨
const finalCount = count ?? 10; // 0</code></pre>
                    </div>
                </div>
                 <p class="highlight">`0`이나 빈 문자열(`''`)을 유효한 값으로 처리하고 싶을 때 `??`를 사용하세요.</p>
            </div>
        </section>

        <!-- Slide 10: typeof & instanceof -->
        <section class="slide" data-slide-id="9">
            <div class="slide-content">
                <h2><i class="fa-solid-tags"></i> 너의 타입은 뭐니? `typeof` & `instanceof`</h2>
                <p>값의 데이터 타입을 확인하는 두 가지 방법을 알아봅시다.</p>
                 <div class="comparison-container">
                    <div class="code-block">
                        <h4><code>typeof</code> 연산자</h4>
                        <p>주로 원시 타입을 확인하는 데 사용됩니다.</p>
                        <pre><code>typeof 123;     // "number"
typeof 'abc';   // "string"
typeof true;    // "boolean"
typeof {};      // "object"
typeof [];      // "object" 🤨
typeof null;    // "object" 🤯</code></pre>
                    </div>
                    <div class="code-block">
                        <h4><code>instanceof</code> 연산자</h4>
                        <p>객체가 특정 클래스의 인스턴스인지 확인합니다.</p>
                        <pre><code>const arr = [];
const date = new Date();

arr instanceof Array;  // true
date instanceof Date;  // true
date instanceof Object; // true</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Slide 11: Summary -->
        <section class="slide" data-slide-id="10">
            <div class="slide-content">
                <h2><i class="fa-solid fa-clipboard-check"></i> 핵심 정리</h2>
                <ul class="summary-list">
                    <li><i class="fa-solid fa-scale-unbalanced-flip"></i> <strong>`===` 사용:</strong> 예측 불가능한 `==` 대신, 타입과 값 모두 비교하는 `===`를 생활화합시다.</li>
                    <li><i class="fa-solid fa-ghost"></i> <strong>Truthy/Falsy 이해:</strong> `if`문과 논리 연산자를 더 유연하게 사용하기 위해 7가지 Falsy 값을 기억하세요.</li>
                    <li><i class="fa-solid fa-bolt-lightning"></i> <strong>단축 평가 활용:</strong> `if`문을 대체하여 간결하고 효율적인 코드를 작성할 수 있습니다.</li>
                    <li><i class="fa-solid fa-link-slash"></i> <strong>`?.` 와 `??`:** 에러 방지와 기본값 설정을 위해 옵셔널 체이닝과 null 병합 연산자를 적극적으로 사용합시다.</li>
                    <li><i class="fa-solid fa-tags"></i> <strong>`typeof` vs `instanceof`:** 원시 타입 확인은 `typeof`, 객체의 구체적인 클래스 확인은 `instanceof`를 사용합니다.</li>
                </ul>
                <p class="final-message">이제 여러분은 연산자를 훨씬 더 깊이 있게 다룰 수 있습니다!</p>
            </div>
        </section>

    </main>

    <div class="navigation">
        <button id="prev-btn" title="이전 슬라이드 (←)"><i class="fas fa-arrow-left"></i></button>
        <span id="slide-counter">1 / 11</span>
        <button id="next-btn" title="다음 슬라이드 (→)"><i class="fas fa-arrow-right"></i></button>
    </div>

    <script src="script.js"></script>
</body>
</html> 